(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.md2pjson = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var defaults = createCommonjsModule(function (module) {
	function getDefaults() {
	  return {
	    baseUrl: null,
	    breaks: false,
	    gfm: true,
	    headerIds: true,
	    headerPrefix: '',
	    highlight: null,
	    langPrefix: 'language-',
	    mangle: true,
	    pedantic: false,
	    renderer: null,
	    sanitize: false,
	    sanitizer: null,
	    silent: false,
	    smartLists: false,
	    smartypants: false,
	    tokenizer: null,
	    walkTokens: null,
	    xhtml: false
	  };
	}

	function changeDefaults(newDefaults) {
	  module.exports.defaults = newDefaults;
	}

	module.exports = {
	  defaults: getDefaults(),
	  getDefaults,
	  changeDefaults
	};
	});

	/**
	 * Helpers
	 */
	const escapeTest = /[&<>"']/;
	const escapeReplace = /[&<>"']/g;
	const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
	const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
	const escapeReplacements = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;'
	};
	const getEscapeReplacement = (ch) => escapeReplacements[ch];
	function escape(html, encode) {
	  if (encode) {
	    if (escapeTest.test(html)) {
	      return html.replace(escapeReplace, getEscapeReplacement);
	    }
	  } else {
	    if (escapeTestNoEncode.test(html)) {
	      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
	    }
	  }

	  return html;
	}

	const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

	function unescape(html) {
	  // explicitly match decimal, hex, and named HTML entities
	  return html.replace(unescapeTest, (_, n) => {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}

	const caret = /(^|[^\[])\^/g;
	function edit(regex, opt) {
	  regex = regex.source || regex;
	  opt = opt || '';
	  const obj = {
	    replace: (name, val) => {
	      val = val.source || val;
	      val = val.replace(caret, '$1');
	      regex = regex.replace(name, val);
	      return obj;
	    },
	    getRegex: () => {
	      return new RegExp(regex, opt);
	    }
	  };
	  return obj;
	}

	const nonWordAndColonTest = /[^\w:]/g;
	const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
	function cleanUrl(sanitize, base, href) {
	  if (sanitize) {
	    let prot;
	    try {
	      prot = decodeURIComponent(unescape(href))
	        .replace(nonWordAndColonTest, '')
	        .toLowerCase();
	    } catch (e) {
	      return null;
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
	      return null;
	    }
	  }
	  if (base && !originIndependentUrl.test(href)) {
	    href = resolveUrl(base, href);
	  }
	  try {
	    href = encodeURI(href).replace(/%25/g, '%');
	  } catch (e) {
	    return null;
	  }
	  return href;
	}

	const baseUrls = {};
	const justDomain = /^[^:]+:\/*[^/]*$/;
	const protocol = /^([^:]+:)[\s\S]*$/;
	const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

	function resolveUrl(base, href) {
	  if (!baseUrls[' ' + base]) {
	    // we can ignore everything in base after the last slash of its path component,
	    // but we might need to add _that_
	    // https://tools.ietf.org/html/rfc3986#section-3
	    if (justDomain.test(base)) {
	      baseUrls[' ' + base] = base + '/';
	    } else {
	      baseUrls[' ' + base] = rtrim(base, '/', true);
	    }
	  }
	  base = baseUrls[' ' + base];
	  const relativeBase = base.indexOf(':') === -1;

	  if (href.substring(0, 2) === '//') {
	    if (relativeBase) {
	      return href;
	    }
	    return base.replace(protocol, '$1') + href;
	  } else if (href.charAt(0) === '/') {
	    if (relativeBase) {
	      return href;
	    }
	    return base.replace(domain, '$1') + href;
	  } else {
	    return base + href;
	  }
	}

	const noopTest = { exec: function noopTest() {} };

	function merge(obj) {
	  let i = 1,
	    target,
	    key;

	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }

	  return obj;
	}

	function splitCells(tableRow, count) {
	  // ensure that every cell-delimiting pipe has a space
	  // before it to distinguish it from an escaped pipe
	  const row = tableRow.replace(/\|/g, (match, offset, str) => {
	      let escaped = false,
	        curr = offset;
	      while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
	      if (escaped) {
	        // odd number of slashes means | is escaped
	        // so we leave it alone
	        return '|';
	      } else {
	        // add space before unescaped |
	        return ' |';
	      }
	    }),
	    cells = row.split(/ \|/);
	  let i = 0;

	  if (cells.length > count) {
	    cells.splice(count);
	  } else {
	    while (cells.length < count) cells.push('');
	  }

	  for (; i < cells.length; i++) {
	    // leading or trailing whitespace is ignored per the gfm spec
	    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
	  }
	  return cells;
	}

	// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
	// /c*$/ is vulnerable to REDOS.
	// invert: Remove suffix of non-c chars instead. Default falsey.
	function rtrim(str, c, invert) {
	  const l = str.length;
	  if (l === 0) {
	    return '';
	  }

	  // Length of suffix matching the invert condition.
	  let suffLen = 0;

	  // Step left until we fail to match the invert condition.
	  while (suffLen < l) {
	    const currChar = str.charAt(l - suffLen - 1);
	    if (currChar === c && !invert) {
	      suffLen++;
	    } else if (currChar !== c && invert) {
	      suffLen++;
	    } else {
	      break;
	    }
	  }

	  return str.substr(0, l - suffLen);
	}

	function findClosingBracket(str, b) {
	  if (str.indexOf(b[1]) === -1) {
	    return -1;
	  }
	  const l = str.length;
	  let level = 0,
	    i = 0;
	  for (; i < l; i++) {
	    if (str[i] === '\\') {
	      i++;
	    } else if (str[i] === b[0]) {
	      level++;
	    } else if (str[i] === b[1]) {
	      level--;
	      if (level < 0) {
	        return i;
	      }
	    }
	  }
	  return -1;
	}

	function checkSanitizeDeprecation(opt) {
	  if (opt && opt.sanitize && !opt.silent) {
	    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
	  }
	}

	// copied from https://stackoverflow.com/a/5450113/806777
	function repeatString(pattern, count) {
	  if (count < 1) {
	    return '';
	  }
	  let result = '';
	  while (count > 1) {
	    if (count & 1) {
	      result += pattern;
	    }
	    count >>= 1;
	    pattern += pattern;
	  }
	  return result + pattern;
	}

	var helpers = {
	  escape,
	  unescape,
	  edit,
	  cleanUrl,
	  resolveUrl,
	  noopTest,
	  merge,
	  splitCells,
	  rtrim,
	  findClosingBracket,
	  checkSanitizeDeprecation,
	  repeatString
	};

	const { defaults: defaults$1 } = defaults;
	const {
	  rtrim: rtrim$1,
	  splitCells: splitCells$1,
	  escape: escape$1,
	  findClosingBracket: findClosingBracket$1
	} = helpers;

	function outputLink(cap, link, raw) {
	  const href = link.href;
	  const title = link.title ? escape$1(link.title) : null;
	  const text = cap[1].replace(/\\([\[\]])/g, '$1');

	  if (cap[0].charAt(0) !== '!') {
	    return {
	      type: 'link',
	      raw,
	      href,
	      title,
	      text
	    };
	  } else {
	    return {
	      type: 'image',
	      raw,
	      href,
	      title,
	      text: escape$1(text)
	    };
	  }
	}

	function indentCodeCompensation(raw, text) {
	  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);

	  if (matchIndentToCode === null) {
	    return text;
	  }

	  const indentToCode = matchIndentToCode[1];

	  return text
	    .split('\n')
	    .map(node => {
	      const matchIndentInNode = node.match(/^\s+/);
	      if (matchIndentInNode === null) {
	        return node;
	      }

	      const [indentInNode] = matchIndentInNode;

	      if (indentInNode.length >= indentToCode.length) {
	        return node.slice(indentToCode.length);
	      }

	      return node;
	    })
	    .join('\n');
	}

	/**
	 * Tokenizer
	 */
	var Tokenizer_1 = class Tokenizer {
	  constructor(options) {
	    this.options = options || defaults$1;
	  }

	  space(src) {
	    const cap = this.rules.block.newline.exec(src);
	    if (cap) {
	      if (cap[0].length > 1) {
	        return {
	          type: 'space',
	          raw: cap[0]
	        };
	      }
	      return { raw: '\n' };
	    }
	  }

	  code(src, tokens) {
	    const cap = this.rules.block.code.exec(src);
	    if (cap) {
	      const lastToken = tokens[tokens.length - 1];
	      // An indented code block cannot interrupt a paragraph.
	      if (lastToken && lastToken.type === 'paragraph') {
	        return {
	          raw: cap[0],
	          text: cap[0].trimRight()
	        };
	      }

	      const text = cap[0].replace(/^ {4}/gm, '');
	      return {
	        type: 'code',
	        raw: cap[0],
	        codeBlockStyle: 'indented',
	        text: !this.options.pedantic
	          ? rtrim$1(text, '\n')
	          : text
	      };
	    }
	  }

	  fences(src) {
	    const cap = this.rules.block.fences.exec(src);
	    if (cap) {
	      const raw = cap[0];
	      const text = indentCodeCompensation(raw, cap[3] || '');

	      return {
	        type: 'code',
	        raw,
	        lang: cap[2] ? cap[2].trim() : cap[2],
	        text
	      };
	    }
	  }

	  heading(src) {
	    const cap = this.rules.block.heading.exec(src);
	    if (cap) {
	      return {
	        type: 'heading',
	        raw: cap[0],
	        depth: cap[1].length,
	        text: cap[2]
	      };
	    }
	  }

	  nptable(src) {
	    const cap = this.rules.block.nptable.exec(src);
	    if (cap) {
	      const item = {
	        type: 'table',
	        header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
	        raw: cap[0]
	      };

	      if (item.header.length === item.align.length) {
	        let l = item.align.length;
	        let i;
	        for (i = 0; i < l; i++) {
	          if (/^ *-+: *$/.test(item.align[i])) {
	            item.align[i] = 'right';
	          } else if (/^ *:-+: *$/.test(item.align[i])) {
	            item.align[i] = 'center';
	          } else if (/^ *:-+ *$/.test(item.align[i])) {
	            item.align[i] = 'left';
	          } else {
	            item.align[i] = null;
	          }
	        }

	        l = item.cells.length;
	        for (i = 0; i < l; i++) {
	          item.cells[i] = splitCells$1(item.cells[i], item.header.length);
	        }

	        return item;
	      }
	    }
	  }

	  hr(src) {
	    const cap = this.rules.block.hr.exec(src);
	    if (cap) {
	      return {
	        type: 'hr',
	        raw: cap[0]
	      };
	    }
	  }

	  blockquote(src) {
	    const cap = this.rules.block.blockquote.exec(src);
	    if (cap) {
	      const text = cap[0].replace(/^ *> ?/gm, '');

	      return {
	        type: 'blockquote',
	        raw: cap[0],
	        text
	      };
	    }
	  }

	  list(src) {
	    const cap = this.rules.block.list.exec(src);
	    if (cap) {
	      let raw = cap[0];
	      const bull = cap[2];
	      const isordered = bull.length > 1;

	      const list = {
	        type: 'list',
	        raw,
	        ordered: isordered,
	        start: isordered ? +bull.slice(0, -1) : '',
	        loose: false,
	        items: []
	      };

	      // Get each top-level item.
	      const itemMatch = cap[0].match(this.rules.block.item);

	      let next = false,
	        item,
	        space,
	        bcurr,
	        bnext,
	        addBack,
	        loose,
	        istask,
	        ischecked;

	      let l = itemMatch.length;
	      bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
	      for (let i = 0; i < l; i++) {
	        item = itemMatch[i];
	        raw = item;

	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (i !== l - 1) {
	          bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);

	          if (bnext[1].length > bcurr[0].length || bnext[1].length > 3) {
	            // nested list
	            itemMatch.splice(i, 2, itemMatch[i] + '\n' + itemMatch[i + 1]);
	            i--;
	            l--;
	            continue;
	          } else {
	            if (
	              // different bullet style
	              !this.options.pedantic || this.options.smartLists
	                ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1]
	                : isordered === (bnext[2].length === 1)
	            ) {
	              addBack = itemMatch.slice(i + 1).join('\n');
	              list.raw = list.raw.substring(0, list.raw.length - addBack.length);
	              i = l - 1;
	            }
	          }
	          bcurr = bnext;
	        }

	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+[.)]) ?/, '');

	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }

	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }

	        if (loose) {
	          list.loose = true;
	        }

	        // Check for task list items
	        istask = /^\[[ xX]\] /.test(item);
	        ischecked = undefined;
	        if (istask) {
	          ischecked = item[1] !== ' ';
	          item = item.replace(/^\[[ xX]\] +/, '');
	        }

	        list.items.push({
	          type: 'list_item',
	          raw,
	          task: istask,
	          checked: ischecked,
	          loose: loose,
	          text: item
	        });
	      }

	      return list;
	    }
	  }

	  html(src) {
	    const cap = this.rules.block.html.exec(src);
	    if (cap) {
	      return {
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        raw: cap[0],
	        pre: !this.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0])) : cap[0]
	      };
	    }
	  }

	  def(src) {
	    const cap = this.rules.block.def.exec(src);
	    if (cap) {
	      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
	      const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
	      return {
	        tag,
	        raw: cap[0],
	        href: cap[2],
	        title: cap[3]
	      };
	    }
	  }

	  table(src) {
	    const cap = this.rules.block.table.exec(src);
	    if (cap) {
	      const item = {
	        type: 'table',
	        header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
	      };

	      if (item.header.length === item.align.length) {
	        item.raw = cap[0];

	        let l = item.align.length;
	        let i;
	        for (i = 0; i < l; i++) {
	          if (/^ *-+: *$/.test(item.align[i])) {
	            item.align[i] = 'right';
	          } else if (/^ *:-+: *$/.test(item.align[i])) {
	            item.align[i] = 'center';
	          } else if (/^ *:-+ *$/.test(item.align[i])) {
	            item.align[i] = 'left';
	          } else {
	            item.align[i] = null;
	          }
	        }

	        l = item.cells.length;
	        for (i = 0; i < l; i++) {
	          item.cells[i] = splitCells$1(
	            item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
	            item.header.length);
	        }

	        return item;
	      }
	    }
	  }

	  lheading(src) {
	    const cap = this.rules.block.lheading.exec(src);
	    if (cap) {
	      return {
	        type: 'heading',
	        raw: cap[0],
	        depth: cap[2].charAt(0) === '=' ? 1 : 2,
	        text: cap[1]
	      };
	    }
	  }

	  paragraph(src) {
	    const cap = this.rules.block.paragraph.exec(src);
	    if (cap) {
	      return {
	        type: 'paragraph',
	        raw: cap[0],
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      };
	    }
	  }

	  text(src, tokens) {
	    const cap = this.rules.block.text.exec(src);
	    if (cap) {
	      const lastToken = tokens[tokens.length - 1];
	      if (lastToken && lastToken.type === 'text') {
	        return {
	          raw: cap[0],
	          text: cap[0]
	        };
	      }

	      return {
	        type: 'text',
	        raw: cap[0],
	        text: cap[0]
	      };
	    }
	  }

	  escape(src) {
	    const cap = this.rules.inline.escape.exec(src);
	    if (cap) {
	      return {
	        type: 'escape',
	        raw: cap[0],
	        text: escape$1(cap[1])
	      };
	    }
	  }

	  tag(src, inLink, inRawBlock) {
	    const cap = this.rules.inline.tag.exec(src);
	    if (cap) {
	      if (!inLink && /^<a /i.test(cap[0])) {
	        inLink = true;
	      } else if (inLink && /^<\/a>/i.test(cap[0])) {
	        inLink = false;
	      }
	      if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
	        inRawBlock = true;
	      } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
	        inRawBlock = false;
	      }

	      return {
	        type: this.options.sanitize
	          ? 'text'
	          : 'html',
	        raw: cap[0],
	        inLink,
	        inRawBlock,
	        text: this.options.sanitize
	          ? (this.options.sanitizer
	            ? this.options.sanitizer(cap[0])
	            : escape$1(cap[0]))
	          : cap[0]
	      };
	    }
	  }

	  link(src) {
	    const cap = this.rules.inline.link.exec(src);
	    if (cap) {
	      const lastParenIndex = findClosingBracket$1(cap[2], '()');
	      if (lastParenIndex > -1) {
	        const start = cap[0].indexOf('!') === 0 ? 5 : 4;
	        const linkLen = start + cap[1].length + lastParenIndex;
	        cap[2] = cap[2].substring(0, lastParenIndex);
	        cap[0] = cap[0].substring(0, linkLen).trim();
	        cap[3] = '';
	      }
	      let href = cap[2];
	      let title = '';
	      if (this.options.pedantic) {
	        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

	        if (link) {
	          href = link[1];
	          title = link[3];
	        } else {
	          title = '';
	        }
	      } else {
	        title = cap[3] ? cap[3].slice(1, -1) : '';
	      }
	      href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
	      const token = outputLink(cap, {
	        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
	        title: title ? title.replace(this.rules.inline._escapes, '$1') : title
	      }, cap[0]);
	      return token;
	    }
	  }

	  reflink(src, links) {
	    let cap;
	    if ((cap = this.rules.inline.reflink.exec(src))
	        || (cap = this.rules.inline.nolink.exec(src))) {
	      let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = links[link.toLowerCase()];
	      if (!link || !link.href) {
	        const text = cap[0].charAt(0);
	        return {
	          type: 'text',
	          raw: text,
	          text
	        };
	      }
	      const token = outputLink(cap, link, cap[0]);
	      return token;
	    }
	  }

	  strong(src, maskedSrc, prevChar = '') {
	    let match = this.rules.inline.strong.start.exec(src);

	    if (match && (!match[1] || (match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))))) {
	      maskedSrc = maskedSrc.slice(-1 * src.length);
	      const endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;

	      endReg.lastIndex = 0;

	      let cap;
	      while ((match = endReg.exec(maskedSrc)) != null) {
	        cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));
	        if (cap) {
	          return {
	            type: 'strong',
	            raw: src.slice(0, cap[0].length),
	            text: src.slice(2, cap[0].length - 2)
	          };
	        }
	      }
	    }
	  }

	  em(src, maskedSrc, prevChar = '') {
	    let match = this.rules.inline.em.start.exec(src);

	    if (match && (!match[1] || (match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))))) {
	      maskedSrc = maskedSrc.slice(-1 * src.length);
	      const endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;

	      endReg.lastIndex = 0;

	      let cap;
	      while ((match = endReg.exec(maskedSrc)) != null) {
	        cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));
	        if (cap) {
	          return {
	            type: 'em',
	            raw: src.slice(0, cap[0].length),
	            text: src.slice(1, cap[0].length - 1)
	          };
	        }
	      }
	    }
	  }

	  codespan(src) {
	    const cap = this.rules.inline.code.exec(src);
	    if (cap) {
	      let text = cap[2].replace(/\n/g, ' ');
	      const hasNonSpaceChars = /[^ ]/.test(text);
	      const hasSpaceCharsOnBothEnds = text.startsWith(' ') && text.endsWith(' ');
	      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
	        text = text.substring(1, text.length - 1);
	      }
	      text = escape$1(text, true);
	      return {
	        type: 'codespan',
	        raw: cap[0],
	        text
	      };
	    }
	  }

	  br(src) {
	    const cap = this.rules.inline.br.exec(src);
	    if (cap) {
	      return {
	        type: 'br',
	        raw: cap[0]
	      };
	    }
	  }

	  del(src) {
	    const cap = this.rules.inline.del.exec(src);
	    if (cap) {
	      return {
	        type: 'del',
	        raw: cap[0],
	        text: cap[1]
	      };
	    }
	  }

	  autolink(src, mangle) {
	    const cap = this.rules.inline.autolink.exec(src);
	    if (cap) {
	      let text, href;
	      if (cap[2] === '@') {
	        text = escape$1(this.options.mangle ? mangle(cap[1]) : cap[1]);
	        href = 'mailto:' + text;
	      } else {
	        text = escape$1(cap[1]);
	        href = text;
	      }

	      return {
	        type: 'link',
	        raw: cap[0],
	        text,
	        href,
	        tokens: [
	          {
	            type: 'text',
	            raw: text,
	            text
	          }
	        ]
	      };
	    }
	  }

	  url(src, mangle) {
	    let cap;
	    if (cap = this.rules.inline.url.exec(src)) {
	      let text, href;
	      if (cap[2] === '@') {
	        text = escape$1(this.options.mangle ? mangle(cap[0]) : cap[0]);
	        href = 'mailto:' + text;
	      } else {
	        // do extended autolink path validation
	        let prevCapZero;
	        do {
	          prevCapZero = cap[0];
	          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
	        } while (prevCapZero !== cap[0]);
	        text = escape$1(cap[0]);
	        if (cap[1] === 'www.') {
	          href = 'http://' + text;
	        } else {
	          href = text;
	        }
	      }
	      return {
	        type: 'link',
	        raw: cap[0],
	        text,
	        href,
	        tokens: [
	          {
	            type: 'text',
	            raw: text,
	            text
	          }
	        ]
	      };
	    }
	  }

	  inlineText(src, inRawBlock, smartypants) {
	    const cap = this.rules.inline.text.exec(src);
	    if (cap) {
	      let text;
	      if (inRawBlock) {
	        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0])) : cap[0];
	      } else {
	        text = escape$1(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
	      }
	      return {
	        type: 'text',
	        raw: cap[0],
	        text
	      };
	    }
	  }
	};

	const {
	  noopTest: noopTest$1,
	  edit: edit$1,
	  merge: merge$1
	} = helpers;

	/**
	 * Block-Level Grammar
	 */
	const block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
	  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
	  heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
	  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
	  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
	  html: '^ {0,3}(?:' // optional indentation
	    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
	    + '|comment[^\\n]*(\\n+|$)' // (2)
	    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
	    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
	    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
	    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
	    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
	    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
	    + ')',
	  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
	  nptable: noopTest$1,
	  table: noopTest$1,
	  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
	  // regex template, placeholders will be replaced according to different paragraph
	  // interruption rules of commonmark and the original markdown spec:
	  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
	  text: /^[^\n]+/
	};

	block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
	block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
	block.def = edit$1(block.def)
	  .replace('label', block._label)
	  .replace('title', block._title)
	  .getRegex();

	block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
	block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
	block.item = edit$1(block.item, 'gm')
	  .replace(/bull/g, block.bullet)
	  .getRegex();

	block.listItemStart = edit$1(/^( *)(bull)/)
	  .replace('bull', block.bullet)
	  .getRegex();

	block.list = edit$1(block.list)
	  .replace(/bull/g, block.bullet)
	  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
	  .replace('def', '\\n+(?=' + block.def.source + ')')
	  .getRegex();

	block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
	  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
	  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
	  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
	  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
	  + '|track|ul';
	block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
	block.html = edit$1(block.html, 'i')
	  .replace('comment', block._comment)
	  .replace('tag', block._tag)
	  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
	  .getRegex();

	block.paragraph = edit$1(block._paragraph)
	  .replace('hr', block.hr)
	  .replace('heading', ' {0,3}#{1,6} ')
	  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
	  .replace('blockquote', ' {0,3}>')
	  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
	  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
	  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
	  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
	  .getRegex();

	block.blockquote = edit$1(block.blockquote)
	  .replace('paragraph', block.paragraph)
	  .getRegex();

	/**
	 * Normal Block Grammar
	 */

	block.normal = merge$1({}, block);

	/**
	 * GFM Block Grammar
	 */

	block.gfm = merge$1({}, block.normal, {
	  nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
	    + ' {0,3}([-:]+ *\\|[-| :]*)' // Align
	    + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)', // Cells
	  table: '^ *\\|(.+)\\n' // Header
	    + ' {0,3}\\|?( *[-:]+[-| :]*)' // Align
	    + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
	});

	block.gfm.nptable = edit$1(block.gfm.nptable)
	  .replace('hr', block.hr)
	  .replace('heading', ' {0,3}#{1,6} ')
	  .replace('blockquote', ' {0,3}>')
	  .replace('code', ' {4}[^\\n]')
	  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
	  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
	  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
	  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
	  .getRegex();

	block.gfm.table = edit$1(block.gfm.table)
	  .replace('hr', block.hr)
	  .replace('heading', ' {0,3}#{1,6} ')
	  .replace('blockquote', ' {0,3}>')
	  .replace('code', ' {4}[^\\n]')
	  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
	  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
	  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
	  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
	  .getRegex();

	/**
	 * Pedantic grammar (original John Gruber's loose markdown specification)
	 */

	block.pedantic = merge$1({}, block.normal, {
	  html: edit$1(
	    '^ *(?:comment *(?:\\n|\\s*$)'
	    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
	    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
	    .replace('comment', block._comment)
	    .replace(/tag/g, '(?!(?:'
	      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
	      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
	      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
	    .getRegex(),
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
	  fences: noopTest$1, // fences not supported
	  paragraph: edit$1(block.normal._paragraph)
	    .replace('hr', block.hr)
	    .replace('heading', ' *#{1,6} *[^\n]')
	    .replace('lheading', block.lheading)
	    .replace('blockquote', ' {0,3}>')
	    .replace('|fences', '')
	    .replace('|list', '')
	    .replace('|html', '')
	    .getRegex()
	});

	/**
	 * Inline-Level Grammar
	 */
	const inline = {
	  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
	  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
	  url: noopTest$1,
	  tag: '^comment'
	    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
	    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
	    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
	    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
	    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
	  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
	  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
	  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
	  reflinkSearch: 'reflink|nolink(?!\\()',
	  strong: {
	    start: /^(?:(\*\*(?=[*punctuation]))|\*\*)(?![\s])|__/, // (1) returns if starts w/ punctuation
	    middle: /^\*\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?)__$/,
	    endAst: /[^punctuation\s]\*\*(?!\*)|[punctuation]\*\*(?!\*)(?:(?=[punctuation_\s]|$))/, // last char can't be punct, or final * must also be followed by punct (or endline)
	    endUnd: /[^\s]__(?!_)(?:(?=[punctuation*\s])|$)/ // last char can't be a space, and final _ must preceed punct or \s (or endline)
	  },
	  em: {
	    start: /^(?:(\*(?=[punctuation]))|\*)(?![*\s])|_/, // (1) returns if starts w/ punctuation
	    middle: /^\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?_$/,
	    endAst: /[^punctuation\s]\*(?!\*)|[punctuation]\*(?!\*)(?:(?=[punctuation_\s]|$))/, // last char can't be punct, or final * must also be followed by punct (or endline)
	    endUnd: /[^\s]_(?!_)(?:(?=[punctuation*\s])|$)/ // last char can't be a space, and final _ must preceed punct or \s (or endline)
	  },
	  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
	  br: /^( {2,}|\\)\n(?!\s*$)/,
	  del: noopTest$1,
	  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n)))/,
	  punctuation: /^([\s*punctuation])/
	};

	// list of punctuation marks from common mark spec
	// without * and _ to workaround cases with double emphasis
	inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
	inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

	// sequences em should skip over [title](link), `code`, <html>
	inline._blockSkip = '\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>';
	inline._overlapSkip = '__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*';

	inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();

	inline.em.start = edit$1(inline.em.start)
	  .replace(/punctuation/g, inline._punctuation)
	  .getRegex();

	inline.em.middle = edit$1(inline.em.middle)
	  .replace(/punctuation/g, inline._punctuation)
	  .replace(/overlapSkip/g, inline._overlapSkip)
	  .getRegex();

	inline.em.endAst = edit$1(inline.em.endAst, 'g')
	  .replace(/punctuation/g, inline._punctuation)
	  .getRegex();

	inline.em.endUnd = edit$1(inline.em.endUnd, 'g')
	  .replace(/punctuation/g, inline._punctuation)
	  .getRegex();

	inline.strong.start = edit$1(inline.strong.start)
	  .replace(/punctuation/g, inline._punctuation)
	  .getRegex();

	inline.strong.middle = edit$1(inline.strong.middle)
	  .replace(/punctuation/g, inline._punctuation)
	  .replace(/overlapSkip/g, inline._overlapSkip)
	  .getRegex();

	inline.strong.endAst = edit$1(inline.strong.endAst, 'g')
	  .replace(/punctuation/g, inline._punctuation)
	  .getRegex();

	inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g')
	  .replace(/punctuation/g, inline._punctuation)
	  .getRegex();

	inline.blockSkip = edit$1(inline._blockSkip, 'g')
	  .getRegex();

	inline.overlapSkip = edit$1(inline._overlapSkip, 'g')
	  .getRegex();

	inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

	inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
	inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
	inline.autolink = edit$1(inline.autolink)
	  .replace('scheme', inline._scheme)
	  .replace('email', inline._email)
	  .getRegex();

	inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

	inline.tag = edit$1(inline.tag)
	  .replace('comment', inline._comment)
	  .replace('attribute', inline._attribute)
	  .getRegex();

	inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
	inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
	inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

	inline.link = edit$1(inline.link)
	  .replace('label', inline._label)
	  .replace('href', inline._href)
	  .replace('title', inline._title)
	  .getRegex();

	inline.reflink = edit$1(inline.reflink)
	  .replace('label', inline._label)
	  .getRegex();

	inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g')
	  .replace('reflink', inline.reflink)
	  .replace('nolink', inline.nolink)
	  .getRegex();

	/**
	 * Normal Inline Grammar
	 */

	inline.normal = merge$1({}, inline);

	/**
	 * Pedantic Inline Grammar
	 */

	inline.pedantic = merge$1({}, inline.normal, {
	  strong: {
	    start: /^__|\*\*/,
	    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	    endAst: /\*\*(?!\*)/g,
	    endUnd: /__(?!_)/g
	  },
	  em: {
	    start: /^_|\*/,
	    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
	    endAst: /\*(?!\*)/g,
	    endUnd: /_(?!_)/g
	  },
	  link: edit$1(/^!?\[(label)\]\((.*?)\)/)
	    .replace('label', inline._label)
	    .getRegex(),
	  reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/)
	    .replace('label', inline._label)
	    .getRegex()
	});

	/**
	 * GFM Inline Grammar
	 */

	inline.gfm = merge$1({}, inline.normal, {
	  escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
	  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
	  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
	  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
	  del: /^~+(?=\S)([\s\S]*?\S)~+/,
	  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
	});

	inline.gfm.url = edit$1(inline.gfm.url, 'i')
	  .replace('email', inline.gfm._extended_email)
	  .getRegex();
	/**
	 * GFM + Line Breaks Inline Grammar
	 */

	inline.breaks = merge$1({}, inline.gfm, {
	  br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
	  text: edit$1(inline.gfm.text)
	    .replace('\\b_', '\\b_| {2,}\\n')
	    .replace(/\{2,\}/g, '*')
	    .getRegex()
	});

	var rules = {
	  block,
	  inline
	};

	const { defaults: defaults$2 } = defaults;
	const { block: block$1, inline: inline$1 } = rules;
	const { repeatString: repeatString$1 } = helpers;

	/**
	 * smartypants text replacement
	 */
	function smartypants(text) {
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	}

	/**
	 * mangle email addresses
	 */
	function mangle(text) {
	  let out = '',
	    i,
	    ch;

	  const l = text.length;
	  for (i = 0; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }

	  return out;
	}

	/**
	 * Block Lexer
	 */
	var Lexer_1 = class Lexer {
	  constructor(options) {
	    this.tokens = [];
	    this.tokens.links = Object.create(null);
	    this.options = options || defaults$2;
	    this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
	    this.tokenizer = this.options.tokenizer;
	    this.tokenizer.options = this.options;

	    const rules = {
	      block: block$1.normal,
	      inline: inline$1.normal
	    };

	    if (this.options.pedantic) {
	      rules.block = block$1.pedantic;
	      rules.inline = inline$1.pedantic;
	    } else if (this.options.gfm) {
	      rules.block = block$1.gfm;
	      if (this.options.breaks) {
	        rules.inline = inline$1.breaks;
	      } else {
	        rules.inline = inline$1.gfm;
	      }
	    }
	    this.tokenizer.rules = rules;
	  }

	  /**
	   * Expose Rules
	   */
	  static get rules() {
	    return {
	      block: block$1,
	      inline: inline$1
	    };
	  }

	  /**
	   * Static Lex Method
	   */
	  static lex(src, options) {
	    const lexer = new Lexer(options);
	    return lexer.lex(src);
	  }

	  /**
	   * Static Lex Inline Method
	   */
	  static lexInline(src, options) {
	    const lexer = new Lexer(options);
	    return lexer.inlineTokens(src);
	  }

	  /**
	   * Preprocessing
	   */
	  lex(src) {
	    src = src
	      .replace(/\r\n|\r/g, '\n')
	      .replace(/\t/g, '    ');

	    this.blockTokens(src, this.tokens, true);

	    this.inline(this.tokens);

	    return this.tokens;
	  }

	  /**
	   * Lexing
	   */
	  blockTokens(src, tokens = [], top = true) {
	    src = src.replace(/^ +$/gm, '');
	    let token, i, l, lastToken;

	    while (src) {
	      // newline
	      if (token = this.tokenizer.space(src)) {
	        src = src.substring(token.raw.length);
	        if (token.type) {
	          tokens.push(token);
	        }
	        continue;
	      }

	      // code
	      if (token = this.tokenizer.code(src, tokens)) {
	        src = src.substring(token.raw.length);
	        if (token.type) {
	          tokens.push(token);
	        } else {
	          lastToken = tokens[tokens.length - 1];
	          lastToken.raw += '\n' + token.raw;
	          lastToken.text += '\n' + token.text;
	        }
	        continue;
	      }

	      // fences
	      if (token = this.tokenizer.fences(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // heading
	      if (token = this.tokenizer.heading(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // table no leading pipe (gfm)
	      if (token = this.tokenizer.nptable(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // hr
	      if (token = this.tokenizer.hr(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // blockquote
	      if (token = this.tokenizer.blockquote(src)) {
	        src = src.substring(token.raw.length);
	        token.tokens = this.blockTokens(token.text, [], top);
	        tokens.push(token);
	        continue;
	      }

	      // list
	      if (token = this.tokenizer.list(src)) {
	        src = src.substring(token.raw.length);
	        l = token.items.length;
	        for (i = 0; i < l; i++) {
	          token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
	        }
	        tokens.push(token);
	        continue;
	      }

	      // html
	      if (token = this.tokenizer.html(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // def
	      if (top && (token = this.tokenizer.def(src))) {
	        src = src.substring(token.raw.length);
	        if (!this.tokens.links[token.tag]) {
	          this.tokens.links[token.tag] = {
	            href: token.href,
	            title: token.title
	          };
	        }
	        continue;
	      }

	      // table (gfm)
	      if (token = this.tokenizer.table(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // lheading
	      if (token = this.tokenizer.lheading(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // top-level paragraph
	      if (top && (token = this.tokenizer.paragraph(src))) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // text
	      if (token = this.tokenizer.text(src, tokens)) {
	        src = src.substring(token.raw.length);
	        if (token.type) {
	          tokens.push(token);
	        } else {
	          lastToken = tokens[tokens.length - 1];
	          lastToken.raw += '\n' + token.raw;
	          lastToken.text += '\n' + token.text;
	        }
	        continue;
	      }

	      if (src) {
	        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
	        if (this.options.silent) {
	          console.error(errMsg);
	          break;
	        } else {
	          throw new Error(errMsg);
	        }
	      }
	    }

	    return tokens;
	  }

	  inline(tokens) {
	    let i,
	      j,
	      k,
	      l2,
	      row,
	      token;

	    const l = tokens.length;
	    for (i = 0; i < l; i++) {
	      token = tokens[i];
	      switch (token.type) {
	        case 'paragraph':
	        case 'text':
	        case 'heading': {
	          token.tokens = [];
	          this.inlineTokens(token.text, token.tokens);
	          break;
	        }
	        case 'table': {
	          token.tokens = {
	            header: [],
	            cells: []
	          };

	          // header
	          l2 = token.header.length;
	          for (j = 0; j < l2; j++) {
	            token.tokens.header[j] = [];
	            this.inlineTokens(token.header[j], token.tokens.header[j]);
	          }

	          // cells
	          l2 = token.cells.length;
	          for (j = 0; j < l2; j++) {
	            row = token.cells[j];
	            token.tokens.cells[j] = [];
	            for (k = 0; k < row.length; k++) {
	              token.tokens.cells[j][k] = [];
	              this.inlineTokens(row[k], token.tokens.cells[j][k]);
	            }
	          }

	          break;
	        }
	        case 'blockquote': {
	          this.inline(token.tokens);
	          break;
	        }
	        case 'list': {
	          l2 = token.items.length;
	          for (j = 0; j < l2; j++) {
	            this.inline(token.items[j].tokens);
	          }
	          break;
	        }
	      }
	    }

	    return tokens;
	  }

	  /**
	   * Lexing/Compiling
	   */
	  inlineTokens(src, tokens = [], inLink = false, inRawBlock = false, prevChar = '') {
	    let token;

	    // String with links masked to avoid interference with em and strong
	    let maskedSrc = src;
	    let match;

	    // Mask out reflinks
	    if (this.tokens.links) {
	      const links = Object.keys(this.tokens.links);
	      if (links.length > 0) {
	        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
	          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
	            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
	          }
	        }
	      }
	    }
	    // Mask out other blocks
	    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
	      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
	    }

	    while (src) {
	      // escape
	      if (token = this.tokenizer.escape(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // tag
	      if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
	        src = src.substring(token.raw.length);
	        inLink = token.inLink;
	        inRawBlock = token.inRawBlock;
	        tokens.push(token);
	        continue;
	      }

	      // link
	      if (token = this.tokenizer.link(src)) {
	        src = src.substring(token.raw.length);
	        if (token.type === 'link') {
	          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
	        }
	        tokens.push(token);
	        continue;
	      }

	      // reflink, nolink
	      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
	        src = src.substring(token.raw.length);
	        if (token.type === 'link') {
	          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
	        }
	        tokens.push(token);
	        continue;
	      }

	      // strong
	      if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {
	        src = src.substring(token.raw.length);
	        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
	        tokens.push(token);
	        continue;
	      }

	      // em
	      if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {
	        src = src.substring(token.raw.length);
	        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
	        tokens.push(token);
	        continue;
	      }

	      // code
	      if (token = this.tokenizer.codespan(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // br
	      if (token = this.tokenizer.br(src)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // del (gfm)
	      if (token = this.tokenizer.del(src)) {
	        src = src.substring(token.raw.length);
	        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
	        tokens.push(token);
	        continue;
	      }

	      // autolink
	      if (token = this.tokenizer.autolink(src, mangle)) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // url (gfm)
	      if (!inLink && (token = this.tokenizer.url(src, mangle))) {
	        src = src.substring(token.raw.length);
	        tokens.push(token);
	        continue;
	      }

	      // text
	      if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
	        src = src.substring(token.raw.length);
	        prevChar = token.raw.slice(-1);
	        tokens.push(token);
	        continue;
	      }

	      if (src) {
	        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
	        if (this.options.silent) {
	          console.error(errMsg);
	          break;
	        } else {
	          throw new Error(errMsg);
	        }
	      }
	    }

	    return tokens;
	  }
	};

	const { defaults: defaults$3 } = defaults;
	const {
	  cleanUrl: cleanUrl$1,
	  escape: escape$2
	} = helpers;

	/**
	 * Renderer
	 */
	var Renderer_1 = class Renderer {
	  constructor(options) {
	    this.options = options || defaults$3;
	  }

	  code(code, infostring, escaped) {
	    const lang = (infostring || '').match(/\S*/)[0];
	    if (this.options.highlight) {
	      const out = this.options.highlight(code, lang);
	      if (out != null && out !== code) {
	        escaped = true;
	        code = out;
	      }
	    }

	    if (!lang) {
	      return '<pre><code>'
	        + (escaped ? code : escape$2(code, true))
	        + '</code></pre>\n';
	    }

	    return '<pre><code class="'
	      + this.options.langPrefix
	      + escape$2(lang, true)
	      + '">'
	      + (escaped ? code : escape$2(code, true))
	      + '</code></pre>\n';
	  }

	  blockquote(quote) {
	    return '<blockquote>\n' + quote + '</blockquote>\n';
	  }

	  html(html) {
	    return html;
	  }

	  heading(text, level, raw, slugger) {
	    if (this.options.headerIds) {
	      return '<h'
	        + level
	        + ' id="'
	        + this.options.headerPrefix
	        + slugger.slug(raw)
	        + '">'
	        + text
	        + '</h'
	        + level
	        + '>\n';
	    }
	    // ignore IDs
	    return '<h' + level + '>' + text + '</h' + level + '>\n';
	  }

	  hr() {
	    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	  }

	  list(body, ordered, start) {
	    const type = ordered ? 'ol' : 'ul',
	      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
	    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
	  }

	  listitem(text) {
	    return '<li>' + text + '</li>\n';
	  }

	  checkbox(checked) {
	    return '<input '
	      + (checked ? 'checked="" ' : '')
	      + 'disabled="" type="checkbox"'
	      + (this.options.xhtml ? ' /' : '')
	      + '> ';
	  }

	  paragraph(text) {
	    return '<p>' + text + '</p>\n';
	  }

	  table(header, body) {
	    if (body) body = '<tbody>' + body + '</tbody>';

	    return '<table>\n'
	      + '<thead>\n'
	      + header
	      + '</thead>\n'
	      + body
	      + '</table>\n';
	  }

	  tablerow(content) {
	    return '<tr>\n' + content + '</tr>\n';
	  }

	  tablecell(content, flags) {
	    const type = flags.header ? 'th' : 'td';
	    const tag = flags.align
	      ? '<' + type + ' align="' + flags.align + '">'
	      : '<' + type + '>';
	    return tag + content + '</' + type + '>\n';
	  }

	  // span level renderer
	  strong(text) {
	    return '<strong>' + text + '</strong>';
	  }

	  em(text) {
	    return '<em>' + text + '</em>';
	  }

	  codespan(text) {
	    return '<code>' + text + '</code>';
	  }

	  br() {
	    return this.options.xhtml ? '<br/>' : '<br>';
	  }

	  del(text) {
	    return '<del>' + text + '</del>';
	  }

	  link(href, title, text) {
	    href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
	    if (href === null) {
	      return text;
	    }
	    let out = '<a href="' + escape$2(href) + '"';
	    if (title) {
	      out += ' title="' + title + '"';
	    }
	    out += '>' + text + '</a>';
	    return out;
	  }

	  image(href, title, text) {
	    href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
	    if (href === null) {
	      return text;
	    }

	    let out = '<img src="' + href + '" alt="' + text + '"';
	    if (title) {
	      out += ' title="' + title + '"';
	    }
	    out += this.options.xhtml ? '/>' : '>';
	    return out;
	  }

	  text(text) {
	    return text;
	  }
	};

	/**
	 * TextRenderer
	 * returns only the textual part of the token
	 */
	var TextRenderer_1 = class TextRenderer {
	  // no need for block level renderers
	  strong(text) {
	    return text;
	  }

	  em(text) {
	    return text;
	  }

	  codespan(text) {
	    return text;
	  }

	  del(text) {
	    return text;
	  }

	  html(text) {
	    return text;
	  }

	  text(text) {
	    return text;
	  }

	  link(href, title, text) {
	    return '' + text;
	  }

	  image(href, title, text) {
	    return '' + text;
	  }

	  br() {
	    return '';
	  }
	};

	/**
	 * Slugger generates header id
	 */
	var Slugger_1 = class Slugger {
	  constructor() {
	    this.seen = {};
	  }

	  serialize(value) {
	    return value
	      .toLowerCase()
	      .trim()
	      // remove html tags
	      .replace(/<[!\/a-z].*?>/ig, '')
	      // remove unwanted chars
	      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
	      .replace(/\s/g, '-');
	  }

	  /**
	   * Finds the next safe (unique) slug to use
	   */
	  getNextSafeSlug(originalSlug, isDryRun) {
	    let slug = originalSlug;
	    let occurenceAccumulator = 0;
	    if (this.seen.hasOwnProperty(slug)) {
	      occurenceAccumulator = this.seen[originalSlug];
	      do {
	        occurenceAccumulator++;
	        slug = originalSlug + '-' + occurenceAccumulator;
	      } while (this.seen.hasOwnProperty(slug));
	    }
	    if (!isDryRun) {
	      this.seen[originalSlug] = occurenceAccumulator;
	      this.seen[slug] = 0;
	    }
	    return slug;
	  }

	  /**
	   * Convert string to unique id
	   * @param {object} options
	   * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
	   */
	  slug(value, options = {}) {
	    const slug = this.serialize(value);
	    return this.getNextSafeSlug(slug, options.dryrun);
	  }
	};

	const { defaults: defaults$4 } = defaults;
	const {
	  unescape: unescape$1
	} = helpers;

	/**
	 * Parsing & Compiling
	 */
	var Parser_1 = class Parser {
	  constructor(options) {
	    this.options = options || defaults$4;
	    this.options.renderer = this.options.renderer || new Renderer_1();
	    this.renderer = this.options.renderer;
	    this.renderer.options = this.options;
	    this.textRenderer = new TextRenderer_1();
	    this.slugger = new Slugger_1();
	  }

	  /**
	   * Static Parse Method
	   */
	  static parse(tokens, options) {
	    const parser = new Parser(options);
	    return parser.parse(tokens);
	  }

	  /**
	   * Static Parse Inline Method
	   */
	  static parseInline(tokens, options) {
	    const parser = new Parser(options);
	    return parser.parseInline(tokens);
	  }

	  /**
	   * Parse Loop
	   */
	  parse(tokens, top = true) {
	    let out = '',
	      i,
	      j,
	      k,
	      l2,
	      l3,
	      row,
	      cell,
	      header,
	      body,
	      token,
	      ordered,
	      start,
	      loose,
	      itemBody,
	      item,
	      checked,
	      task,
	      checkbox;

	    const l = tokens.length;
	    for (i = 0; i < l; i++) {
	      token = tokens[i];
	      switch (token.type) {
	        case 'space': {
	          continue;
	        }
	        case 'hr': {
	          out += this.renderer.hr();
	          continue;
	        }
	        case 'heading': {
	          out += this.renderer.heading(
	            this.parseInline(token.tokens),
	            token.depth,
	            unescape$1(this.parseInline(token.tokens, this.textRenderer)),
	            this.slugger);
	          continue;
	        }
	        case 'code': {
	          out += this.renderer.code(token.text,
	            token.lang,
	            token.escaped);
	          continue;
	        }
	        case 'table': {
	          header = '';

	          // header
	          cell = '';
	          l2 = token.header.length;
	          for (j = 0; j < l2; j++) {
	            cell += this.renderer.tablecell(
	              this.parseInline(token.tokens.header[j]),
	              { header: true, align: token.align[j] }
	            );
	          }
	          header += this.renderer.tablerow(cell);

	          body = '';
	          l2 = token.cells.length;
	          for (j = 0; j < l2; j++) {
	            row = token.tokens.cells[j];

	            cell = '';
	            l3 = row.length;
	            for (k = 0; k < l3; k++) {
	              cell += this.renderer.tablecell(
	                this.parseInline(row[k]),
	                { header: false, align: token.align[k] }
	              );
	            }

	            body += this.renderer.tablerow(cell);
	          }
	          out += this.renderer.table(header, body);
	          continue;
	        }
	        case 'blockquote': {
	          body = this.parse(token.tokens);
	          out += this.renderer.blockquote(body);
	          continue;
	        }
	        case 'list': {
	          ordered = token.ordered;
	          start = token.start;
	          loose = token.loose;
	          l2 = token.items.length;

	          body = '';
	          for (j = 0; j < l2; j++) {
	            item = token.items[j];
	            checked = item.checked;
	            task = item.task;

	            itemBody = '';
	            if (item.task) {
	              checkbox = this.renderer.checkbox(checked);
	              if (loose) {
	                if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
	                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
	                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
	                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
	                  }
	                } else {
	                  item.tokens.unshift({
	                    type: 'text',
	                    text: checkbox
	                  });
	                }
	              } else {
	                itemBody += checkbox;
	              }
	            }

	            itemBody += this.parse(item.tokens, loose);
	            body += this.renderer.listitem(itemBody, task, checked);
	          }

	          out += this.renderer.list(body, ordered, start);
	          continue;
	        }
	        case 'html': {
	          // TODO parse inline content if parameter markdown=1
	          out += this.renderer.html(token.text);
	          continue;
	        }
	        case 'paragraph': {
	          out += this.renderer.paragraph(this.parseInline(token.tokens));
	          continue;
	        }
	        case 'text': {
	          body = token.tokens ? this.parseInline(token.tokens) : token.text;
	          while (i + 1 < l && tokens[i + 1].type === 'text') {
	            token = tokens[++i];
	            body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
	          }
	          out += top ? this.renderer.paragraph(body) : body;
	          continue;
	        }
	        default: {
	          const errMsg = 'Token with "' + token.type + '" type was not found.';
	          if (this.options.silent) {
	            console.error(errMsg);
	            return;
	          } else {
	            throw new Error(errMsg);
	          }
	        }
	      }
	    }

	    return out;
	  }

	  /**
	   * Parse Inline Tokens
	   */
	  parseInline(tokens, renderer) {
	    renderer = renderer || this.renderer;
	    let out = '',
	      i,
	      token;

	    const l = tokens.length;
	    for (i = 0; i < l; i++) {
	      token = tokens[i];
	      switch (token.type) {
	        case 'escape': {
	          out += renderer.text(token.text);
	          break;
	        }
	        case 'html': {
	          out += renderer.html(token.text);
	          break;
	        }
	        case 'link': {
	          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
	          break;
	        }
	        case 'image': {
	          out += renderer.image(token.href, token.title, token.text);
	          break;
	        }
	        case 'strong': {
	          out += renderer.strong(this.parseInline(token.tokens, renderer));
	          break;
	        }
	        case 'em': {
	          out += renderer.em(this.parseInline(token.tokens, renderer));
	          break;
	        }
	        case 'codespan': {
	          out += renderer.codespan(token.text);
	          break;
	        }
	        case 'br': {
	          out += renderer.br();
	          break;
	        }
	        case 'del': {
	          out += renderer.del(this.parseInline(token.tokens, renderer));
	          break;
	        }
	        case 'text': {
	          out += renderer.text(token.text);
	          break;
	        }
	        default: {
	          const errMsg = 'Token with "' + token.type + '" type was not found.';
	          if (this.options.silent) {
	            console.error(errMsg);
	            return;
	          } else {
	            throw new Error(errMsg);
	          }
	        }
	      }
	    }
	    return out;
	  }
	};

	const {
	  merge: merge$2,
	  checkSanitizeDeprecation: checkSanitizeDeprecation$1,
	  escape: escape$3
	} = helpers;
	const {
	  getDefaults,
	  changeDefaults,
	  defaults: defaults$5
	} = defaults;

	/**
	 * Marked
	 */
	function marked(src, opt, callback) {
	  // throw error in case of non string input
	  if (typeof src === 'undefined' || src === null) {
	    throw new Error('marked(): input parameter is undefined or null');
	  }
	  if (typeof src !== 'string') {
	    throw new Error('marked(): input parameter is of type '
	      + Object.prototype.toString.call(src) + ', string expected');
	  }

	  if (typeof opt === 'function') {
	    callback = opt;
	    opt = null;
	  }

	  opt = merge$2({}, marked.defaults, opt || {});
	  checkSanitizeDeprecation$1(opt);

	  if (callback) {
	    const highlight = opt.highlight;
	    let tokens;

	    try {
	      tokens = Lexer_1.lex(src, opt);
	    } catch (e) {
	      return callback(e);
	    }

	    const done = function(err) {
	      let out;

	      if (!err) {
	        try {
	          out = Parser_1.parse(tokens, opt);
	        } catch (e) {
	          err = e;
	        }
	      }

	      opt.highlight = highlight;

	      return err
	        ? callback(err)
	        : callback(null, out);
	    };

	    if (!highlight || highlight.length < 3) {
	      return done();
	    }

	    delete opt.highlight;

	    if (!tokens.length) return done();

	    let pending = 0;
	    marked.walkTokens(tokens, function(token) {
	      if (token.type === 'code') {
	        pending++;
	        setTimeout(() => {
	          highlight(token.text, token.lang, function(err, code) {
	            if (err) {
	              return done(err);
	            }
	            if (code != null && code !== token.text) {
	              token.text = code;
	              token.escaped = true;
	            }

	            pending--;
	            if (pending === 0) {
	              done();
	            }
	          });
	        }, 0);
	      }
	    });

	    if (pending === 0) {
	      done();
	    }

	    return;
	  }

	  try {
	    const tokens = Lexer_1.lex(src, opt);
	    if (opt.walkTokens) {
	      marked.walkTokens(tokens, opt.walkTokens);
	    }
	    return Parser_1.parse(tokens, opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
	    if (opt.silent) {
	      return '<p>An error occurred:</p><pre>'
	        + escape$3(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}

	/**
	 * Options
	 */

	marked.options =
	marked.setOptions = function(opt) {
	  merge$2(marked.defaults, opt);
	  changeDefaults(marked.defaults);
	  return marked;
	};

	marked.getDefaults = getDefaults;

	marked.defaults = defaults$5;

	/**
	 * Use Extension
	 */

	marked.use = function(extension) {
	  const opts = merge$2({}, extension);
	  if (extension.renderer) {
	    const renderer = marked.defaults.renderer || new Renderer_1();
	    for (const prop in extension.renderer) {
	      const prevRenderer = renderer[prop];
	      renderer[prop] = (...args) => {
	        let ret = extension.renderer[prop].apply(renderer, args);
	        if (ret === false) {
	          ret = prevRenderer.apply(renderer, args);
	        }
	        return ret;
	      };
	    }
	    opts.renderer = renderer;
	  }
	  if (extension.tokenizer) {
	    const tokenizer = marked.defaults.tokenizer || new Tokenizer_1();
	    for (const prop in extension.tokenizer) {
	      const prevTokenizer = tokenizer[prop];
	      tokenizer[prop] = (...args) => {
	        let ret = extension.tokenizer[prop].apply(tokenizer, args);
	        if (ret === false) {
	          ret = prevTokenizer.apply(tokenizer, args);
	        }
	        return ret;
	      };
	    }
	    opts.tokenizer = tokenizer;
	  }
	  if (extension.walkTokens) {
	    const walkTokens = marked.defaults.walkTokens;
	    opts.walkTokens = (token) => {
	      extension.walkTokens(token);
	      if (walkTokens) {
	        walkTokens(token);
	      }
	    };
	  }
	  marked.setOptions(opts);
	};

	/**
	 * Run callback for every token
	 */

	marked.walkTokens = function(tokens, callback) {
	  for (const token of tokens) {
	    callback(token);
	    switch (token.type) {
	      case 'table': {
	        for (const cell of token.tokens.header) {
	          marked.walkTokens(cell, callback);
	        }
	        for (const row of token.tokens.cells) {
	          for (const cell of row) {
	            marked.walkTokens(cell, callback);
	          }
	        }
	        break;
	      }
	      case 'list': {
	        marked.walkTokens(token.items, callback);
	        break;
	      }
	      default: {
	        if (token.tokens) {
	          marked.walkTokens(token.tokens, callback);
	        }
	      }
	    }
	  }
	};

	/**
	 * Parse Inline
	 */
	marked.parseInline = function(src, opt) {
	  // throw error in case of non string input
	  if (typeof src === 'undefined' || src === null) {
	    throw new Error('marked.parseInline(): input parameter is undefined or null');
	  }
	  if (typeof src !== 'string') {
	    throw new Error('marked.parseInline(): input parameter is of type '
	      + Object.prototype.toString.call(src) + ', string expected');
	  }

	  opt = merge$2({}, marked.defaults, opt || {});
	  checkSanitizeDeprecation$1(opt);

	  try {
	    const tokens = Lexer_1.lexInline(src, opt);
	    if (opt.walkTokens) {
	      marked.walkTokens(tokens, opt.walkTokens);
	    }
	    return Parser_1.parseInline(tokens, opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
	    if (opt.silent) {
	      return '<p>An error occurred:</p><pre>'
	        + escape$3(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	};

	/**
	 * Expose
	 */

	marked.Parser = Parser_1;
	marked.parser = Parser_1.parse;

	marked.Renderer = Renderer_1;
	marked.TextRenderer = TextRenderer_1;

	marked.Lexer = Lexer_1;
	marked.lexer = Lexer_1.lex;

	marked.Tokenizer = Tokenizer_1;

	marked.Slugger = Slugger_1;

	marked.parse = marked;

	var marked_1 = marked;

	const Char = {
	  ANCHOR: '&',
	  COMMENT: '#',
	  TAG: '!',
	  DIRECTIVES_END: '-',
	  DOCUMENT_END: '.'
	};
	const Type = {
	  ALIAS: 'ALIAS',
	  BLANK_LINE: 'BLANK_LINE',
	  BLOCK_FOLDED: 'BLOCK_FOLDED',
	  BLOCK_LITERAL: 'BLOCK_LITERAL',
	  COMMENT: 'COMMENT',
	  DIRECTIVE: 'DIRECTIVE',
	  DOCUMENT: 'DOCUMENT',
	  FLOW_MAP: 'FLOW_MAP',
	  FLOW_SEQ: 'FLOW_SEQ',
	  MAP: 'MAP',
	  MAP_KEY: 'MAP_KEY',
	  MAP_VALUE: 'MAP_VALUE',
	  PLAIN: 'PLAIN',
	  QUOTE_DOUBLE: 'QUOTE_DOUBLE',
	  QUOTE_SINGLE: 'QUOTE_SINGLE',
	  SEQ: 'SEQ',
	  SEQ_ITEM: 'SEQ_ITEM'
	};
	const defaultTagPrefix = 'tag:yaml.org,2002:';
	const defaultTags = {
	  MAP: 'tag:yaml.org,2002:map',
	  SEQ: 'tag:yaml.org,2002:seq',
	  STR: 'tag:yaml.org,2002:str'
	};

	function findLineStarts(src) {
	  const ls = [0];
	  let offset = src.indexOf('\n');

	  while (offset !== -1) {
	    offset += 1;
	    ls.push(offset);
	    offset = src.indexOf('\n', offset);
	  }

	  return ls;
	}

	function getSrcInfo(cst) {
	  let lineStarts, src;

	  if (typeof cst === 'string') {
	    lineStarts = findLineStarts(cst);
	    src = cst;
	  } else {
	    if (Array.isArray(cst)) cst = cst[0];

	    if (cst && cst.context) {
	      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
	      lineStarts = cst.lineStarts;
	      src = cst.context.src;
	    }
	  }

	  return {
	    lineStarts,
	    src
	  };
	}
	/**
	 * @typedef {Object} LinePos - One-indexed position in the source
	 * @property {number} line
	 * @property {number} col
	 */

	/**
	 * Determine the line/col position matching a character offset.
	 *
	 * Accepts a source string or a CST document as the second parameter. With
	 * the latter, starting indices for lines are cached in the document as
	 * `lineStarts: number[]`.
	 *
	 * Returns a one-indexed `{ line, col }` location if found, or
	 * `undefined` otherwise.
	 *
	 * @param {number} offset
	 * @param {string|Document|Document[]} cst
	 * @returns {?LinePos}
	 */


	function getLinePos(offset, cst) {
	  if (typeof offset !== 'number' || offset < 0) return null;
	  const {
	    lineStarts,
	    src
	  } = getSrcInfo(cst);
	  if (!lineStarts || !src || offset > src.length) return null;

	  for (let i = 0; i < lineStarts.length; ++i) {
	    const start = lineStarts[i];

	    if (offset < start) {
	      return {
	        line: i,
	        col: offset - lineStarts[i - 1] + 1
	      };
	    }

	    if (offset === start) return {
	      line: i + 1,
	      col: 1
	    };
	  }

	  const line = lineStarts.length;
	  return {
	    line,
	    col: offset - lineStarts[line - 1] + 1
	  };
	}
	/**
	 * Get a specified line from the source.
	 *
	 * Accepts a source string or a CST document as the second parameter. With
	 * the latter, starting indices for lines are cached in the document as
	 * `lineStarts: number[]`.
	 *
	 * Returns the line as a string if found, or `null` otherwise.
	 *
	 * @param {number} line One-indexed line number
	 * @param {string|Document|Document[]} cst
	 * @returns {?string}
	 */

	function getLine(line, cst) {
	  const {
	    lineStarts,
	    src
	  } = getSrcInfo(cst);
	  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
	  const start = lineStarts[line - 1];
	  let end = lineStarts[line]; // undefined for last line; that's ok for slice()

	  while (end && end > start && src[end - 1] === '\n') --end;

	  return src.slice(start, end);
	}
	/**
	 * Pretty-print the starting line from the source indicated by the range `pos`
	 *
	 * Trims output to `maxWidth` chars while keeping the starting column visible,
	 * using `…` at either end to indicate dropped characters.
	 *
	 * Returns a two-line string (or `null`) with `\n` as separator; the second line
	 * will hold appropriately indented `^` marks indicating the column range.
	 *
	 * @param {Object} pos
	 * @param {LinePos} pos.start
	 * @param {LinePos} [pos.end]
	 * @param {string|Document|Document[]*} cst
	 * @param {number} [maxWidth=80]
	 * @returns {?string}
	 */

	function getPrettyContext({
	  start,
	  end
	}, cst, maxWidth = 80) {
	  let src = getLine(start.line, cst);
	  if (!src) return null;
	  let {
	    col
	  } = start;

	  if (src.length > maxWidth) {
	    if (col <= maxWidth - 10) {
	      src = src.substr(0, maxWidth - 1) + '…';
	    } else {
	      const halfWidth = Math.round(maxWidth / 2);
	      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';
	      col -= src.length - maxWidth;
	      src = '…' + src.substr(1 - maxWidth);
	    }
	  }

	  let errLen = 1;
	  let errEnd = '';

	  if (end) {
	    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
	      errLen = end.col - start.col;
	    } else {
	      errLen = Math.min(src.length + 1, maxWidth) - col;
	      errEnd = '…';
	    }
	  }

	  const offset = col > 1 ? ' '.repeat(col - 1) : '';
	  const err = '^'.repeat(errLen);
	  return `${src}\n${offset}${err}${errEnd}`;
	}

	class Range {
	  static copy(orig) {
	    return new Range(orig.start, orig.end);
	  }

	  constructor(start, end) {
	    this.start = start;
	    this.end = end || start;
	  }

	  isEmpty() {
	    return typeof this.start !== 'number' || !this.end || this.end <= this.start;
	  }
	  /**
	   * Set `origStart` and `origEnd` to point to the original source range for
	   * this node, which may differ due to dropped CR characters.
	   *
	   * @param {number[]} cr - Positions of dropped CR characters
	   * @param {number} offset - Starting index of `cr` from the last call
	   * @returns {number} - The next offset, matching the one found for `origStart`
	   */


	  setOrigRange(cr, offset) {
	    const {
	      start,
	      end
	    } = this;

	    if (cr.length === 0 || end <= cr[0]) {
	      this.origStart = start;
	      this.origEnd = end;
	      return offset;
	    }

	    let i = offset;

	    while (i < cr.length) {
	      if (cr[i] > start) break;else ++i;
	    }

	    this.origStart = start + i;
	    const nextOffset = i;

	    while (i < cr.length) {
	      // if end was at \n, it should now be at \r
	      if (cr[i] >= end) break;else ++i;
	    }

	    this.origEnd = end + i;
	    return nextOffset;
	  }

	}

	/** Root class of all nodes */

	class Node {
	  static addStringTerminator(src, offset, str) {
	    if (str[str.length - 1] === '\n') return str;
	    const next = Node.endOfWhiteSpace(src, offset);
	    return next >= src.length || src[next] === '\n' ? str + '\n' : str;
	  } // ^(---|...)


	  static atDocumentBoundary(src, offset, sep) {
	    const ch0 = src[offset];
	    if (!ch0) return true;
	    const prev = src[offset - 1];
	    if (prev && prev !== '\n') return false;

	    if (sep) {
	      if (ch0 !== sep) return false;
	    } else {
	      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
	    }

	    const ch1 = src[offset + 1];
	    const ch2 = src[offset + 2];
	    if (ch1 !== ch0 || ch2 !== ch0) return false;
	    const ch3 = src[offset + 3];
	    return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
	  }

	  static endOfIdentifier(src, offset) {
	    let ch = src[offset];
	    const isVerbatim = ch === '<';
	    const notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];

	    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];

	    if (isVerbatim && ch === '>') offset += 1;
	    return offset;
	  }

	  static endOfIndent(src, offset) {
	    let ch = src[offset];

	    while (ch === ' ') ch = src[offset += 1];

	    return offset;
	  }

	  static endOfLine(src, offset) {
	    let ch = src[offset];

	    while (ch && ch !== '\n') ch = src[offset += 1];

	    return offset;
	  }

	  static endOfWhiteSpace(src, offset) {
	    let ch = src[offset];

	    while (ch === '\t' || ch === ' ') ch = src[offset += 1];

	    return offset;
	  }

	  static startOfLine(src, offset) {
	    let ch = src[offset - 1];
	    if (ch === '\n') return offset;

	    while (ch && ch !== '\n') ch = src[offset -= 1];

	    return offset + 1;
	  }
	  /**
	   * End of indentation, or null if the line's indent level is not more
	   * than `indent`
	   *
	   * @param {string} src
	   * @param {number} indent
	   * @param {number} lineStart
	   * @returns {?number}
	   */


	  static endOfBlockIndent(src, indent, lineStart) {
	    const inEnd = Node.endOfIndent(src, lineStart);

	    if (inEnd > lineStart + indent) {
	      return inEnd;
	    } else {
	      const wsEnd = Node.endOfWhiteSpace(src, inEnd);
	      const ch = src[wsEnd];
	      if (!ch || ch === '\n') return wsEnd;
	    }

	    return null;
	  }

	  static atBlank(src, offset, endAsBlank) {
	    const ch = src[offset];
	    return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
	  }

	  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
	    if (!ch || indentDiff < 0) return false;
	    if (indentDiff > 0) return true;
	    return indicatorAsIndent && ch === '-';
	  } // should be at line or string end, or at next non-whitespace char


	  static normalizeOffset(src, offset) {
	    const ch = src[offset];
	    return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
	  } // fold single newline into space, multiple newlines to N - 1 newlines
	  // presumes src[offset] === '\n'


	  static foldNewline(src, offset, indent) {
	    let inCount = 0;
	    let error = false;
	    let fold = '';
	    let ch = src[offset + 1];

	    while (ch === ' ' || ch === '\t' || ch === '\n') {
	      switch (ch) {
	        case '\n':
	          inCount = 0;
	          offset += 1;
	          fold += '\n';
	          break;

	        case '\t':
	          if (inCount <= indent) error = true;
	          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
	          break;

	        case ' ':
	          inCount += 1;
	          offset += 1;
	          break;
	      }

	      ch = src[offset + 1];
	    }

	    if (!fold) fold = ' ';
	    if (ch && inCount <= indent) error = true;
	    return {
	      fold,
	      offset,
	      error
	    };
	  }

	  constructor(type, props, context) {
	    Object.defineProperty(this, 'context', {
	      value: context || null,
	      writable: true
	    });
	    this.error = null;
	    this.range = null;
	    this.valueRange = null;
	    this.props = props || [];
	    this.type = type;
	    this.value = null;
	  }

	  getPropValue(idx, key, skipKey) {
	    if (!this.context) return null;
	    const {
	      src
	    } = this.context;
	    const prop = this.props[idx];
	    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
	  }

	  get anchor() {
	    for (let i = 0; i < this.props.length; ++i) {
	      const anchor = this.getPropValue(i, Char.ANCHOR, true);
	      if (anchor != null) return anchor;
	    }

	    return null;
	  }

	  get comment() {
	    const comments = [];

	    for (let i = 0; i < this.props.length; ++i) {
	      const comment = this.getPropValue(i, Char.COMMENT, true);
	      if (comment != null) comments.push(comment);
	    }

	    return comments.length > 0 ? comments.join('\n') : null;
	  }

	  commentHasRequiredWhitespace(start) {
	    const {
	      src
	    } = this.context;
	    if (this.header && start === this.header.end) return false;
	    if (!this.valueRange) return false;
	    const {
	      end
	    } = this.valueRange;
	    return start !== end || Node.atBlank(src, end - 1);
	  }

	  get hasComment() {
	    if (this.context) {
	      const {
	        src
	      } = this.context;

	      for (let i = 0; i < this.props.length; ++i) {
	        if (src[this.props[i].start] === Char.COMMENT) return true;
	      }
	    }

	    return false;
	  }

	  get hasProps() {
	    if (this.context) {
	      const {
	        src
	      } = this.context;

	      for (let i = 0; i < this.props.length; ++i) {
	        if (src[this.props[i].start] !== Char.COMMENT) return true;
	      }
	    }

	    return false;
	  }

	  get includesTrailingLines() {
	    return false;
	  }

	  get jsonLike() {
	    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
	    return jsonLikeTypes.indexOf(this.type) !== -1;
	  }

	  get rangeAsLinePos() {
	    if (!this.range || !this.context) return undefined;
	    const start = getLinePos(this.range.start, this.context.root);
	    if (!start) return undefined;
	    const end = getLinePos(this.range.end, this.context.root);
	    return {
	      start,
	      end
	    };
	  }

	  get rawValue() {
	    if (!this.valueRange || !this.context) return null;
	    const {
	      start,
	      end
	    } = this.valueRange;
	    return this.context.src.slice(start, end);
	  }

	  get tag() {
	    for (let i = 0; i < this.props.length; ++i) {
	      const tag = this.getPropValue(i, Char.TAG, false);

	      if (tag != null) {
	        if (tag[1] === '<') {
	          return {
	            verbatim: tag.slice(2, -1)
	          };
	        } else {
	          // eslint-disable-next-line no-unused-vars
	          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
	          return {
	            handle,
	            suffix
	          };
	        }
	      }
	    }

	    return null;
	  }

	  get valueRangeContainsNewline() {
	    if (!this.valueRange || !this.context) return false;
	    const {
	      start,
	      end
	    } = this.valueRange;
	    const {
	      src
	    } = this.context;

	    for (let i = start; i < end; ++i) {
	      if (src[i] === '\n') return true;
	    }

	    return false;
	  }

	  parseComment(start) {
	    const {
	      src
	    } = this.context;

	    if (src[start] === Char.COMMENT) {
	      const end = Node.endOfLine(src, start + 1);
	      const commentRange = new Range(start, end);
	      this.props.push(commentRange);
	      return end;
	    }

	    return start;
	  }
	  /**
	   * Populates the `origStart` and `origEnd` values of all ranges for this
	   * node. Extended by child classes to handle descendant nodes.
	   *
	   * @param {number[]} cr - Positions of dropped CR characters
	   * @param {number} offset - Starting index of `cr` from the last call
	   * @returns {number} - The next offset, matching the one found for `origStart`
	   */


	  setOrigRanges(cr, offset) {
	    if (this.range) offset = this.range.setOrigRange(cr, offset);
	    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
	    this.props.forEach(prop => prop.setOrigRange(cr, offset));
	    return offset;
	  }

	  toString() {
	    const {
	      context: {
	        src
	      },
	      range,
	      value
	    } = this;
	    if (value != null) return value;
	    const str = src.slice(range.start, range.end);
	    return Node.addStringTerminator(src, range.end, str);
	  }

	}

	class YAMLError extends Error {
	  constructor(name, source, message) {
	    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);
	    super();
	    this.name = name;
	    this.message = message;
	    this.source = source;
	  }

	  makePretty() {
	    if (!this.source) return;
	    this.nodeType = this.source.type;
	    const cst = this.source.context && this.source.context.root;

	    if (typeof this.offset === 'number') {
	      this.range = new Range(this.offset, this.offset + 1);
	      const start = cst && getLinePos(this.offset, cst);

	      if (start) {
	        const end = {
	          line: start.line,
	          col: start.col + 1
	        };
	        this.linePos = {
	          start,
	          end
	        };
	      }

	      delete this.offset;
	    } else {
	      this.range = this.source.range;
	      this.linePos = this.source.rangeAsLinePos;
	    }

	    if (this.linePos) {
	      const {
	        line,
	        col
	      } = this.linePos.start;
	      this.message += ` at line ${line}, column ${col}`;
	      const ctx = cst && getPrettyContext(this.linePos, cst);
	      if (ctx) this.message += `:\n\n${ctx}\n`;
	    }

	    delete this.source;
	  }

	}
	class YAMLReferenceError extends YAMLError {
	  constructor(source, message) {
	    super('YAMLReferenceError', source, message);
	  }

	}
	class YAMLSemanticError extends YAMLError {
	  constructor(source, message) {
	    super('YAMLSemanticError', source, message);
	  }

	}
	class YAMLSyntaxError extends YAMLError {
	  constructor(source, message) {
	    super('YAMLSyntaxError', source, message);
	  }

	}
	class YAMLWarning extends YAMLError {
	  constructor(source, message) {
	    super('YAMLWarning', source, message);
	  }

	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	class PlainValue extends Node {
	  static endOfLine(src, start, inFlow) {
	    let ch = src[start];
	    let offset = start;

	    while (ch && ch !== '\n') {
	      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
	      const next = src[offset + 1];
	      if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ',')) break;
	      if ((ch === ' ' || ch === '\t') && next === '#') break;
	      offset += 1;
	      ch = next;
	    }

	    return offset;
	  }

	  get strValue() {
	    if (!this.valueRange || !this.context) return null;
	    let {
	      start,
	      end
	    } = this.valueRange;
	    const {
	      src
	    } = this.context;
	    let ch = src[end - 1];

	    while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) ch = src[--end - 1];

	    let str = '';

	    for (let i = start; i < end; ++i) {
	      const ch = src[i];

	      if (ch === '\n') {
	        const {
	          fold,
	          offset
	        } = Node.foldNewline(src, i, -1);
	        str += fold;
	        i = offset;
	      } else if (ch === ' ' || ch === '\t') {
	        // trim trailing whitespace
	        const wsStart = i;
	        let next = src[i + 1];

	        while (i < end && (next === ' ' || next === '\t')) {
	          i += 1;
	          next = src[i + 1];
	        }

	        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
	      } else {
	        str += ch;
	      }
	    }

	    const ch0 = src[start];

	    switch (ch0) {
	      case '\t':
	        {
	          const msg = 'Plain value cannot start with a tab character';
	          const errors = [new YAMLSemanticError(this, msg)];
	          return {
	            errors,
	            str
	          };
	        }

	      case '@':
	      case '`':
	        {
	          const msg = `Plain value cannot start with reserved character ${ch0}`;
	          const errors = [new YAMLSemanticError(this, msg)];
	          return {
	            errors,
	            str
	          };
	        }

	      default:
	        return str;
	    }
	  }

	  parseBlockValue(start) {
	    const {
	      indent,
	      inFlow,
	      src
	    } = this.context;
	    let offset = start;
	    let valueEnd = start;

	    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
	      if (Node.atDocumentBoundary(src, offset + 1)) break;
	      const end = Node.endOfBlockIndent(src, indent, offset + 1);
	      if (end === null || src[end] === '#') break;

	      if (src[end] === '\n') {
	        offset = end;
	      } else {
	        valueEnd = PlainValue.endOfLine(src, end, inFlow);
	        offset = valueEnd;
	      }
	    }

	    if (this.valueRange.isEmpty()) this.valueRange.start = start;
	    this.valueRange.end = valueEnd;
	    return valueEnd;
	  }
	  /**
	   * Parses a plain value from the source
	   *
	   * Accepted forms are:
	   * ```
	   * #comment
	   *
	   * first line
	   *
	   * first line #comment
	   *
	   * first line
	   * block
	   * lines
	   *
	   * #comment
	   * block
	   * lines
	   * ```
	   * where block lines are empty or have an indent level greater than `indent`.
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this scalar, may be `\n`
	   */


	  parse(context, start) {
	    this.context = context;
	    const {
	      inFlow,
	      src
	    } = context;
	    let offset = start;
	    const ch = src[offset];

	    if (ch && ch !== '#' && ch !== '\n') {
	      offset = PlainValue.endOfLine(src, start, inFlow);
	    }

	    this.valueRange = new Range(start, offset);
	    offset = Node.endOfWhiteSpace(src, offset);
	    offset = this.parseComment(offset);

	    if (!this.hasComment || this.valueRange.isEmpty()) {
	      offset = this.parseBlockValue(offset);
	    }

	    return offset;
	  }

	}

	var Char_1 = Char;
	var Node_1 = Node;
	var PlainValue_1 = PlainValue;
	var Range_1 = Range;
	var Type_1 = Type;
	var YAMLError_1 = YAMLError;
	var YAMLReferenceError_1 = YAMLReferenceError;
	var YAMLSemanticError_1 = YAMLSemanticError;
	var YAMLSyntaxError_1 = YAMLSyntaxError;
	var YAMLWarning_1 = YAMLWarning;
	var _defineProperty_1 = _defineProperty;
	var defaultTagPrefix_1 = defaultTagPrefix;
	var defaultTags_1 = defaultTags;

	var PlainValueEc8e588e = {
		Char: Char_1,
		Node: Node_1,
		PlainValue: PlainValue_1,
		Range: Range_1,
		Type: Type_1,
		YAMLError: YAMLError_1,
		YAMLReferenceError: YAMLReferenceError_1,
		YAMLSemanticError: YAMLSemanticError_1,
		YAMLSyntaxError: YAMLSyntaxError_1,
		YAMLWarning: YAMLWarning_1,
		_defineProperty: _defineProperty_1,
		defaultTagPrefix: defaultTagPrefix_1,
		defaultTags: defaultTags_1
	};

	class BlankLine extends PlainValueEc8e588e.Node {
	  constructor() {
	    super(PlainValueEc8e588e.Type.BLANK_LINE);
	  }
	  /* istanbul ignore next */


	  get includesTrailingLines() {
	    // This is never called from anywhere, but if it were,
	    // this is the value it should return.
	    return true;
	  }
	  /**
	   * Parses a blank line from the source
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first \n character
	   * @returns {number} - Index of the character after this
	   */


	  parse(context, start) {
	    this.context = context;
	    this.range = new PlainValueEc8e588e.Range(start, start + 1);
	    return start + 1;
	  }

	}

	class CollectionItem extends PlainValueEc8e588e.Node {
	  constructor(type, props) {
	    super(type, props);
	    this.node = null;
	  }

	  get includesTrailingLines() {
	    return !!this.node && this.node.includesTrailingLines;
	  }
	  /**
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this
	   */


	  parse(context, start) {
	    this.context = context;
	    const {
	      parseNode,
	      src
	    } = context;
	    let {
	      atLineStart,
	      lineStart
	    } = context;
	    if (!atLineStart && this.type === PlainValueEc8e588e.Type.SEQ_ITEM) this.error = new PlainValueEc8e588e.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
	    const indent = atLineStart ? start - lineStart : context.indent;
	    let offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, start + 1);
	    let ch = src[offset];
	    const inlineComment = ch === '#';
	    const comments = [];
	    let blankLine = null;

	    while (ch === '\n' || ch === '#') {
	      if (ch === '#') {
	        const end = PlainValueEc8e588e.Node.endOfLine(src, offset + 1);
	        comments.push(new PlainValueEc8e588e.Range(offset, end));
	        offset = end;
	      } else {
	        atLineStart = true;
	        lineStart = offset + 1;
	        const wsEnd = PlainValueEc8e588e.Node.endOfWhiteSpace(src, lineStart);

	        if (src[wsEnd] === '\n' && comments.length === 0) {
	          blankLine = new BlankLine();
	          lineStart = blankLine.parse({
	            src
	          }, lineStart);
	        }

	        offset = PlainValueEc8e588e.Node.endOfIndent(src, lineStart);
	      }

	      ch = src[offset];
	    }

	    if (PlainValueEc8e588e.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValueEc8e588e.Type.SEQ_ITEM)) {
	      this.node = parseNode({
	        atLineStart,
	        inCollection: false,
	        indent,
	        lineStart,
	        parent: this
	      }, offset);
	    } else if (ch && lineStart > start + 1) {
	      offset = lineStart - 1;
	    }

	    if (this.node) {
	      if (blankLine) {
	        // Only blank lines preceding non-empty nodes are captured. Note that
	        // this means that collection item range start indices do not always
	        // increase monotonically. -- eemeli/yaml#126
	        const items = context.parent.items || context.parent.contents;
	        if (items) items.push(blankLine);
	      }

	      if (comments.length) Array.prototype.push.apply(this.props, comments);
	      offset = this.node.range.end;
	    } else {
	      if (inlineComment) {
	        const c = comments[0];
	        this.props.push(c);
	        offset = c.end;
	      } else {
	        offset = PlainValueEc8e588e.Node.endOfLine(src, start + 1);
	      }
	    }

	    const end = this.node ? this.node.valueRange.end : offset;
	    this.valueRange = new PlainValueEc8e588e.Range(start, end);
	    return offset;
	  }

	  setOrigRanges(cr, offset) {
	    offset = super.setOrigRanges(cr, offset);
	    return this.node ? this.node.setOrigRanges(cr, offset) : offset;
	  }

	  toString() {
	    const {
	      context: {
	        src
	      },
	      node,
	      range,
	      value
	    } = this;
	    if (value != null) return value;
	    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
	    return PlainValueEc8e588e.Node.addStringTerminator(src, range.end, str);
	  }

	}

	class Comment extends PlainValueEc8e588e.Node {
	  constructor() {
	    super(PlainValueEc8e588e.Type.COMMENT);
	  }
	  /**
	   * Parses a comment line from the source
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this scalar
	   */


	  parse(context, start) {
	    this.context = context;
	    const offset = this.parseComment(start);
	    this.range = new PlainValueEc8e588e.Range(start, offset);
	    return offset;
	  }

	}

	function grabCollectionEndComments(node) {
	  let cnode = node;

	  while (cnode instanceof CollectionItem) cnode = cnode.node;

	  if (!(cnode instanceof Collection)) return null;
	  const len = cnode.items.length;
	  let ci = -1;

	  for (let i = len - 1; i >= 0; --i) {
	    const n = cnode.items[i];

	    if (n.type === PlainValueEc8e588e.Type.COMMENT) {
	      // Keep sufficiently indented comments with preceding node
	      const {
	        indent,
	        lineStart
	      } = n.context;
	      if (indent > 0 && n.range.start >= lineStart + indent) break;
	      ci = i;
	    } else if (n.type === PlainValueEc8e588e.Type.BLANK_LINE) ci = i;else break;
	  }

	  if (ci === -1) return null;
	  const ca = cnode.items.splice(ci, len - ci);
	  const prevEnd = ca[0].range.start;

	  while (true) {
	    cnode.range.end = prevEnd;
	    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
	    if (cnode === node) break;
	    cnode = cnode.context.parent;
	  }

	  return ca;
	}
	class Collection extends PlainValueEc8e588e.Node {
	  static nextContentHasIndent(src, offset, indent) {
	    const lineStart = PlainValueEc8e588e.Node.endOfLine(src, offset) + 1;
	    offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, lineStart);
	    const ch = src[offset];
	    if (!ch) return false;
	    if (offset >= lineStart + indent) return true;
	    if (ch !== '#' && ch !== '\n') return false;
	    return Collection.nextContentHasIndent(src, offset, indent);
	  }

	  constructor(firstItem) {
	    super(firstItem.type === PlainValueEc8e588e.Type.SEQ_ITEM ? PlainValueEc8e588e.Type.SEQ : PlainValueEc8e588e.Type.MAP);

	    for (let i = firstItem.props.length - 1; i >= 0; --i) {
	      if (firstItem.props[i].start < firstItem.context.lineStart) {
	        // props on previous line are assumed by the collection
	        this.props = firstItem.props.slice(0, i + 1);
	        firstItem.props = firstItem.props.slice(i + 1);
	        const itemRange = firstItem.props[0] || firstItem.valueRange;
	        firstItem.range.start = itemRange.start;
	        break;
	      }
	    }

	    this.items = [firstItem];
	    const ec = grabCollectionEndComments(firstItem);
	    if (ec) Array.prototype.push.apply(this.items, ec);
	  }

	  get includesTrailingLines() {
	    return this.items.length > 0;
	  }
	  /**
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this
	   */


	  parse(context, start) {
	    this.context = context;
	    const {
	      parseNode,
	      src
	    } = context; // It's easier to recalculate lineStart here rather than tracking down the
	    // last context from which to read it -- eemeli/yaml#2

	    let lineStart = PlainValueEc8e588e.Node.startOfLine(src, start);
	    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
	    // -- eemeli/yaml#17

	    firstItem.context.parent = this;
	    this.valueRange = PlainValueEc8e588e.Range.copy(firstItem.valueRange);
	    const indent = firstItem.range.start - firstItem.context.lineStart;
	    let offset = start;
	    offset = PlainValueEc8e588e.Node.normalizeOffset(src, offset);
	    let ch = src[offset];
	    let atLineStart = PlainValueEc8e588e.Node.endOfWhiteSpace(src, lineStart) === offset;
	    let prevIncludesTrailingLines = false;

	    while (ch) {
	      while (ch === '\n' || ch === '#') {
	        if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
	          const blankLine = new BlankLine();
	          offset = blankLine.parse({
	            src
	          }, offset);
	          this.valueRange.end = offset;

	          if (offset >= src.length) {
	            ch = null;
	            break;
	          }

	          this.items.push(blankLine);
	          offset -= 1; // blankLine.parse() consumes terminal newline
	        } else if (ch === '#') {
	          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
	            return offset;
	          }

	          const comment = new Comment();
	          offset = comment.parse({
	            indent,
	            lineStart,
	            src
	          }, offset);
	          this.items.push(comment);
	          this.valueRange.end = offset;

	          if (offset >= src.length) {
	            ch = null;
	            break;
	          }
	        }

	        lineStart = offset + 1;
	        offset = PlainValueEc8e588e.Node.endOfIndent(src, lineStart);

	        if (PlainValueEc8e588e.Node.atBlank(src, offset)) {
	          const wsEnd = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	          const next = src[wsEnd];

	          if (!next || next === '\n' || next === '#') {
	            offset = wsEnd;
	          }
	        }

	        ch = src[offset];
	        atLineStart = true;
	      }

	      if (!ch) {
	        break;
	      }

	      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
	        if (offset < lineStart + indent) {
	          if (lineStart > start) offset = lineStart;
	          break;
	        } else if (!this.error) {
	          const msg = 'All collection items must start at the same column';
	          this.error = new PlainValueEc8e588e.YAMLSyntaxError(this, msg);
	        }
	      }

	      if (firstItem.type === PlainValueEc8e588e.Type.SEQ_ITEM) {
	        if (ch !== '-') {
	          if (lineStart > start) offset = lineStart;
	          break;
	        }
	      } else if (ch === '-' && !this.error) {
	        // map key may start with -, as long as it's followed by a non-whitespace char
	        const next = src[offset + 1];

	        if (!next || next === '\n' || next === '\t' || next === ' ') {
	          const msg = 'A collection cannot be both a mapping and a sequence';
	          this.error = new PlainValueEc8e588e.YAMLSyntaxError(this, msg);
	        }
	      }

	      const node = parseNode({
	        atLineStart,
	        inCollection: true,
	        indent,
	        lineStart,
	        parent: this
	      }, offset);
	      if (!node) return offset; // at next document start

	      this.items.push(node);
	      this.valueRange.end = node.valueRange.end;
	      offset = PlainValueEc8e588e.Node.normalizeOffset(src, node.range.end);
	      ch = src[offset];
	      atLineStart = false;
	      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
	      // has advanced to check the current line's indentation level
	      // -- eemeli/yaml#10 & eemeli/yaml#38

	      if (ch) {
	        let ls = offset - 1;
	        let prev = src[ls];

	        while (prev === ' ' || prev === '\t') prev = src[--ls];

	        if (prev === '\n') {
	          lineStart = ls + 1;
	          atLineStart = true;
	        }
	      }

	      const ec = grabCollectionEndComments(node);
	      if (ec) Array.prototype.push.apply(this.items, ec);
	    }

	    return offset;
	  }

	  setOrigRanges(cr, offset) {
	    offset = super.setOrigRanges(cr, offset);
	    this.items.forEach(node => {
	      offset = node.setOrigRanges(cr, offset);
	    });
	    return offset;
	  }

	  toString() {
	    const {
	      context: {
	        src
	      },
	      items,
	      range,
	      value
	    } = this;
	    if (value != null) return value;
	    let str = src.slice(range.start, items[0].range.start) + String(items[0]);

	    for (let i = 1; i < items.length; ++i) {
	      const item = items[i];
	      const {
	        atLineStart,
	        indent
	      } = item.context;
	      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';
	      str += String(item);
	    }

	    return PlainValueEc8e588e.Node.addStringTerminator(src, range.end, str);
	  }

	}

	class Directive extends PlainValueEc8e588e.Node {
	  constructor() {
	    super(PlainValueEc8e588e.Type.DIRECTIVE);
	    this.name = null;
	  }

	  get parameters() {
	    const raw = this.rawValue;
	    return raw ? raw.trim().split(/[ \t]+/) : [];
	  }

	  parseName(start) {
	    const {
	      src
	    } = this.context;
	    let offset = start;
	    let ch = src[offset];

	    while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') ch = src[offset += 1];

	    this.name = src.slice(start, offset);
	    return offset;
	  }

	  parseParameters(start) {
	    const {
	      src
	    } = this.context;
	    let offset = start;
	    let ch = src[offset];

	    while (ch && ch !== '\n' && ch !== '#') ch = src[offset += 1];

	    this.valueRange = new PlainValueEc8e588e.Range(start, offset);
	    return offset;
	  }

	  parse(context, start) {
	    this.context = context;
	    let offset = this.parseName(start + 1);
	    offset = this.parseParameters(offset);
	    offset = this.parseComment(offset);
	    this.range = new PlainValueEc8e588e.Range(start, offset);
	    return offset;
	  }

	}

	class Document extends PlainValueEc8e588e.Node {
	  static startCommentOrEndBlankLine(src, start) {
	    const offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, start);
	    const ch = src[offset];
	    return ch === '#' || ch === '\n' ? offset : start;
	  }

	  constructor() {
	    super(PlainValueEc8e588e.Type.DOCUMENT);
	    this.directives = null;
	    this.contents = null;
	    this.directivesEndMarker = null;
	    this.documentEndMarker = null;
	  }

	  parseDirectives(start) {
	    const {
	      src
	    } = this.context;
	    this.directives = [];
	    let atLineStart = true;
	    let hasDirectives = false;
	    let offset = start;

	    while (!PlainValueEc8e588e.Node.atDocumentBoundary(src, offset, PlainValueEc8e588e.Char.DIRECTIVES_END)) {
	      offset = Document.startCommentOrEndBlankLine(src, offset);

	      switch (src[offset]) {
	        case '\n':
	          if (atLineStart) {
	            const blankLine = new BlankLine();
	            offset = blankLine.parse({
	              src
	            }, offset);

	            if (offset < src.length) {
	              this.directives.push(blankLine);
	            }
	          } else {
	            offset += 1;
	            atLineStart = true;
	          }

	          break;

	        case '#':
	          {
	            const comment = new Comment();
	            offset = comment.parse({
	              src
	            }, offset);
	            this.directives.push(comment);
	            atLineStart = false;
	          }
	          break;

	        case '%':
	          {
	            const directive = new Directive();
	            offset = directive.parse({
	              parent: this,
	              src
	            }, offset);
	            this.directives.push(directive);
	            hasDirectives = true;
	            atLineStart = false;
	          }
	          break;

	        default:
	          if (hasDirectives) {
	            this.error = new PlainValueEc8e588e.YAMLSemanticError(this, 'Missing directives-end indicator line');
	          } else if (this.directives.length > 0) {
	            this.contents = this.directives;
	            this.directives = [];
	          }

	          return offset;
	      }
	    }

	    if (src[offset]) {
	      this.directivesEndMarker = new PlainValueEc8e588e.Range(offset, offset + 3);
	      return offset + 3;
	    }

	    if (hasDirectives) {
	      this.error = new PlainValueEc8e588e.YAMLSemanticError(this, 'Missing directives-end indicator line');
	    } else if (this.directives.length > 0) {
	      this.contents = this.directives;
	      this.directives = [];
	    }

	    return offset;
	  }

	  parseContents(start) {
	    const {
	      parseNode,
	      src
	    } = this.context;
	    if (!this.contents) this.contents = [];
	    let lineStart = start;

	    while (src[lineStart - 1] === '-') lineStart -= 1;

	    let offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, start);
	    let atLineStart = lineStart === start;
	    this.valueRange = new PlainValueEc8e588e.Range(offset);

	    while (!PlainValueEc8e588e.Node.atDocumentBoundary(src, offset, PlainValueEc8e588e.Char.DOCUMENT_END)) {
	      switch (src[offset]) {
	        case '\n':
	          if (atLineStart) {
	            const blankLine = new BlankLine();
	            offset = blankLine.parse({
	              src
	            }, offset);

	            if (offset < src.length) {
	              this.contents.push(blankLine);
	            }
	          } else {
	            offset += 1;
	            atLineStart = true;
	          }

	          lineStart = offset;
	          break;

	        case '#':
	          {
	            const comment = new Comment();
	            offset = comment.parse({
	              src
	            }, offset);
	            this.contents.push(comment);
	            atLineStart = false;
	          }
	          break;

	        default:
	          {
	            const iEnd = PlainValueEc8e588e.Node.endOfIndent(src, offset);
	            const context = {
	              atLineStart,
	              indent: -1,
	              inFlow: false,
	              inCollection: false,
	              lineStart,
	              parent: this
	            };
	            const node = parseNode(context, iEnd);
	            if (!node) return this.valueRange.end = iEnd; // at next document start

	            this.contents.push(node);
	            offset = node.range.end;
	            atLineStart = false;
	            const ec = grabCollectionEndComments(node);
	            if (ec) Array.prototype.push.apply(this.contents, ec);
	          }
	      }

	      offset = Document.startCommentOrEndBlankLine(src, offset);
	    }

	    this.valueRange.end = offset;

	    if (src[offset]) {
	      this.documentEndMarker = new PlainValueEc8e588e.Range(offset, offset + 3);
	      offset += 3;

	      if (src[offset]) {
	        offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);

	        if (src[offset] === '#') {
	          const comment = new Comment();
	          offset = comment.parse({
	            src
	          }, offset);
	          this.contents.push(comment);
	        }

	        switch (src[offset]) {
	          case '\n':
	            offset += 1;
	            break;

	          case undefined:
	            break;

	          default:
	            this.error = new PlainValueEc8e588e.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
	        }
	      }
	    }

	    return offset;
	  }
	  /**
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this
	   */


	  parse(context, start) {
	    context.root = this;
	    this.context = context;
	    const {
	      src
	    } = context;
	    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

	    offset = this.parseDirectives(offset);
	    offset = this.parseContents(offset);
	    return offset;
	  }

	  setOrigRanges(cr, offset) {
	    offset = super.setOrigRanges(cr, offset);
	    this.directives.forEach(node => {
	      offset = node.setOrigRanges(cr, offset);
	    });
	    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
	    this.contents.forEach(node => {
	      offset = node.setOrigRanges(cr, offset);
	    });
	    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
	    return offset;
	  }

	  toString() {
	    const {
	      contents,
	      directives,
	      value
	    } = this;
	    if (value != null) return value;
	    let str = directives.join('');

	    if (contents.length > 0) {
	      if (directives.length > 0 || contents[0].type === PlainValueEc8e588e.Type.COMMENT) str += '---\n';
	      str += contents.join('');
	    }

	    if (str[str.length - 1] !== '\n') str += '\n';
	    return str;
	  }

	}

	class Alias extends PlainValueEc8e588e.Node {
	  /**
	   * Parses an *alias from the source
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this scalar
	   */
	  parse(context, start) {
	    this.context = context;
	    const {
	      src
	    } = context;
	    let offset = PlainValueEc8e588e.Node.endOfIdentifier(src, start + 1);
	    this.valueRange = new PlainValueEc8e588e.Range(start + 1, offset);
	    offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	    offset = this.parseComment(offset);
	    return offset;
	  }

	}

	const Chomp = {
	  CLIP: 'CLIP',
	  KEEP: 'KEEP',
	  STRIP: 'STRIP'
	};
	class BlockValue extends PlainValueEc8e588e.Node {
	  constructor(type, props) {
	    super(type, props);
	    this.blockIndent = null;
	    this.chomping = Chomp.CLIP;
	    this.header = null;
	  }

	  get includesTrailingLines() {
	    return this.chomping === Chomp.KEEP;
	  }

	  get strValue() {
	    if (!this.valueRange || !this.context) return null;
	    let {
	      start,
	      end
	    } = this.valueRange;
	    const {
	      indent,
	      src
	    } = this.context;
	    if (this.valueRange.isEmpty()) return '';
	    let lastNewLine = null;
	    let ch = src[end - 1];

	    while (ch === '\n' || ch === '\t' || ch === ' ') {
	      end -= 1;

	      if (end <= start) {
	        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
	      }

	      if (ch === '\n') lastNewLine = end;
	      ch = src[end - 1];
	    }

	    let keepStart = end + 1;

	    if (lastNewLine) {
	      if (this.chomping === Chomp.KEEP) {
	        keepStart = lastNewLine;
	        end = this.valueRange.end;
	      } else {
	        end = lastNewLine;
	      }
	    }

	    const bi = indent + this.blockIndent;
	    const folded = this.type === PlainValueEc8e588e.Type.BLOCK_FOLDED;
	    let atStart = true;
	    let str = '';
	    let sep = '';
	    let prevMoreIndented = false;

	    for (let i = start; i < end; ++i) {
	      for (let j = 0; j < bi; ++j) {
	        if (src[i] !== ' ') break;
	        i += 1;
	      }

	      const ch = src[i];

	      if (ch === '\n') {
	        if (sep === '\n') str += '\n';else sep = '\n';
	      } else {
	        const lineEnd = PlainValueEc8e588e.Node.endOfLine(src, i);
	        const line = src.slice(i, lineEnd);
	        i = lineEnd;

	        if (folded && (ch === ' ' || ch === '\t') && i < keepStart) {
	          if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
	          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

	          sep = lineEnd < end && src[lineEnd] || '';
	          prevMoreIndented = true;
	        } else {
	          str += sep + line;
	          sep = folded && i < keepStart ? ' ' : '\n';
	          prevMoreIndented = false;
	        }

	        if (atStart && line !== '') atStart = false;
	      }
	    }

	    return this.chomping === Chomp.STRIP ? str : str + '\n';
	  }

	  parseBlockHeader(start) {
	    const {
	      src
	    } = this.context;
	    let offset = start + 1;
	    let bi = '';

	    while (true) {
	      const ch = src[offset];

	      switch (ch) {
	        case '-':
	          this.chomping = Chomp.STRIP;
	          break;

	        case '+':
	          this.chomping = Chomp.KEEP;
	          break;

	        case '0':
	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	          bi += ch;
	          break;

	        default:
	          this.blockIndent = Number(bi) || null;
	          this.header = new PlainValueEc8e588e.Range(start, offset);
	          return offset;
	      }

	      offset += 1;
	    }
	  }

	  parseBlockValue(start) {
	    const {
	      indent,
	      src
	    } = this.context;
	    const explicit = !!this.blockIndent;
	    let offset = start;
	    let valueEnd = start;
	    let minBlockIndent = 1;

	    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
	      offset += 1;
	      if (PlainValueEc8e588e.Node.atDocumentBoundary(src, offset)) break;
	      const end = PlainValueEc8e588e.Node.endOfBlockIndent(src, indent, offset); // should not include tab?

	      if (end === null) break;
	      const ch = src[end];
	      const lineIndent = end - (offset + indent);

	      if (!this.blockIndent) {
	        // no explicit block indent, none yet detected
	        if (src[end] !== '\n') {
	          // first line with non-whitespace content
	          if (lineIndent < minBlockIndent) {
	            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
	            this.error = new PlainValueEc8e588e.YAMLSemanticError(this, msg);
	          }

	          this.blockIndent = lineIndent;
	        } else if (lineIndent > minBlockIndent) {
	          // empty line with more whitespace
	          minBlockIndent = lineIndent;
	        }
	      } else if (ch && ch !== '\n' && lineIndent < this.blockIndent) {
	        if (src[end] === '#') break;

	        if (!this.error) {
	          const src = explicit ? 'explicit indentation indicator' : 'first line';
	          const msg = `Block scalars must not be less indented than their ${src}`;
	          this.error = new PlainValueEc8e588e.YAMLSemanticError(this, msg);
	        }
	      }

	      if (src[end] === '\n') {
	        offset = end;
	      } else {
	        offset = valueEnd = PlainValueEc8e588e.Node.endOfLine(src, end);
	      }
	    }

	    if (this.chomping !== Chomp.KEEP) {
	      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
	    }

	    this.valueRange = new PlainValueEc8e588e.Range(start + 1, offset);
	    return offset;
	  }
	  /**
	   * Parses a block value from the source
	   *
	   * Accepted forms are:
	   * ```
	   * BS
	   * block
	   * lines
	   *
	   * BS #comment
	   * block
	   * lines
	   * ```
	   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
	   * are empty or have an indent level greater than `indent`.
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this block
	   */


	  parse(context, start) {
	    this.context = context;
	    const {
	      src
	    } = context;
	    let offset = this.parseBlockHeader(start);
	    offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	    offset = this.parseComment(offset);
	    offset = this.parseBlockValue(offset);
	    return offset;
	  }

	  setOrigRanges(cr, offset) {
	    offset = super.setOrigRanges(cr, offset);
	    return this.header ? this.header.setOrigRange(cr, offset) : offset;
	  }

	}

	class FlowCollection extends PlainValueEc8e588e.Node {
	  constructor(type, props) {
	    super(type, props);
	    this.items = null;
	  }

	  prevNodeIsJsonLike(idx = this.items.length) {
	    const node = this.items[idx - 1];
	    return !!node && (node.jsonLike || node.type === PlainValueEc8e588e.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
	  }
	  /**
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this
	   */


	  parse(context, start) {
	    this.context = context;
	    const {
	      parseNode,
	      src
	    } = context;
	    let {
	      indent,
	      lineStart
	    } = context;
	    let char = src[start]; // { or [

	    this.items = [{
	      char,
	      offset: start
	    }];
	    let offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, start + 1);
	    char = src[offset];

	    while (char && char !== ']' && char !== '}') {
	      switch (char) {
	        case '\n':
	          {
	            lineStart = offset + 1;
	            const wsEnd = PlainValueEc8e588e.Node.endOfWhiteSpace(src, lineStart);

	            if (src[wsEnd] === '\n') {
	              const blankLine = new BlankLine();
	              lineStart = blankLine.parse({
	                src
	              }, lineStart);
	              this.items.push(blankLine);
	            }

	            offset = PlainValueEc8e588e.Node.endOfIndent(src, lineStart);

	            if (offset <= lineStart + indent) {
	              char = src[offset];

	              if (offset < lineStart + indent || char !== ']' && char !== '}') {
	                const msg = 'Insufficient indentation in flow collection';
	                this.error = new PlainValueEc8e588e.YAMLSemanticError(this, msg);
	              }
	            }
	          }
	          break;

	        case ',':
	          {
	            this.items.push({
	              char,
	              offset
	            });
	            offset += 1;
	          }
	          break;

	        case '#':
	          {
	            const comment = new Comment();
	            offset = comment.parse({
	              src
	            }, offset);
	            this.items.push(comment);
	          }
	          break;

	        case '?':
	        case ':':
	          {
	            const next = src[offset + 1];

	            if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
	            char === ':' && this.prevNodeIsJsonLike()) {
	              this.items.push({
	                char,
	                offset
	              });
	              offset += 1;
	              break;
	            }
	          }
	        // fallthrough

	        default:
	          {
	            const node = parseNode({
	              atLineStart: false,
	              inCollection: false,
	              inFlow: true,
	              indent: -1,
	              lineStart,
	              parent: this
	            }, offset);

	            if (!node) {
	              // at next document start
	              this.valueRange = new PlainValueEc8e588e.Range(start, offset);
	              return offset;
	            }

	            this.items.push(node);
	            offset = PlainValueEc8e588e.Node.normalizeOffset(src, node.range.end);
	          }
	      }

	      offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	      char = src[offset];
	    }

	    this.valueRange = new PlainValueEc8e588e.Range(start, offset + 1);

	    if (char) {
	      this.items.push({
	        char,
	        offset
	      });
	      offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset + 1);
	      offset = this.parseComment(offset);
	    }

	    return offset;
	  }

	  setOrigRanges(cr, offset) {
	    offset = super.setOrigRanges(cr, offset);
	    this.items.forEach(node => {
	      if (node instanceof PlainValueEc8e588e.Node) {
	        offset = node.setOrigRanges(cr, offset);
	      } else if (cr.length === 0) {
	        node.origOffset = node.offset;
	      } else {
	        let i = offset;

	        while (i < cr.length) {
	          if (cr[i] > node.offset) break;else ++i;
	        }

	        node.origOffset = node.offset + i;
	        offset = i;
	      }
	    });
	    return offset;
	  }

	  toString() {
	    const {
	      context: {
	        src
	      },
	      items,
	      range,
	      value
	    } = this;
	    if (value != null) return value;
	    const nodes = items.filter(item => item instanceof PlainValueEc8e588e.Node);
	    let str = '';
	    let prevEnd = range.start;
	    nodes.forEach(node => {
	      const prefix = src.slice(prevEnd, node.range.start);
	      prevEnd = node.range.end;
	      str += prefix + String(node);

	      if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
	        // Comment range does not include the terminal newline, but its
	        // stringified value does. Without this fix, newlines at comment ends
	        // get duplicated.
	        prevEnd += 1;
	      }
	    });
	    str += src.slice(prevEnd, range.end);
	    return PlainValueEc8e588e.Node.addStringTerminator(src, range.end, str);
	  }

	}

	class QuoteDouble extends PlainValueEc8e588e.Node {
	  static endOfQuote(src, offset) {
	    let ch = src[offset];

	    while (ch && ch !== '"') {
	      offset += ch === '\\' ? 2 : 1;
	      ch = src[offset];
	    }

	    return offset + 1;
	  }
	  /**
	   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
	   */


	  get strValue() {
	    if (!this.valueRange || !this.context) return null;
	    const errors = [];
	    const {
	      start,
	      end
	    } = this.valueRange;
	    const {
	      indent,
	      src
	    } = this.context;
	    if (src[end - 1] !== '"') errors.push(new PlainValueEc8e588e.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
	    // escaped backslashes; also, this should be faster.

	    let str = '';

	    for (let i = start + 1; i < end - 1; ++i) {
	      const ch = src[i];

	      if (ch === '\n') {
	        if (PlainValueEc8e588e.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValueEc8e588e.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
	        const {
	          fold,
	          offset,
	          error
	        } = PlainValueEc8e588e.Node.foldNewline(src, i, indent);
	        str += fold;
	        i = offset;
	        if (error) errors.push(new PlainValueEc8e588e.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
	      } else if (ch === '\\') {
	        i += 1;

	        switch (src[i]) {
	          case '0':
	            str += '\0';
	            break;
	          // null character

	          case 'a':
	            str += '\x07';
	            break;
	          // bell character

	          case 'b':
	            str += '\b';
	            break;
	          // backspace

	          case 'e':
	            str += '\x1b';
	            break;
	          // escape character

	          case 'f':
	            str += '\f';
	            break;
	          // form feed

	          case 'n':
	            str += '\n';
	            break;
	          // line feed

	          case 'r':
	            str += '\r';
	            break;
	          // carriage return

	          case 't':
	            str += '\t';
	            break;
	          // horizontal tab

	          case 'v':
	            str += '\v';
	            break;
	          // vertical tab

	          case 'N':
	            str += '\u0085';
	            break;
	          // Unicode next line

	          case '_':
	            str += '\u00a0';
	            break;
	          // Unicode non-breaking space

	          case 'L':
	            str += '\u2028';
	            break;
	          // Unicode line separator

	          case 'P':
	            str += '\u2029';
	            break;
	          // Unicode paragraph separator

	          case ' ':
	            str += ' ';
	            break;

	          case '"':
	            str += '"';
	            break;

	          case '/':
	            str += '/';
	            break;

	          case '\\':
	            str += '\\';
	            break;

	          case '\t':
	            str += '\t';
	            break;

	          case 'x':
	            str += this.parseCharCode(i + 1, 2, errors);
	            i += 2;
	            break;

	          case 'u':
	            str += this.parseCharCode(i + 1, 4, errors);
	            i += 4;
	            break;

	          case 'U':
	            str += this.parseCharCode(i + 1, 8, errors);
	            i += 8;
	            break;

	          case '\n':
	            // skip escaped newlines, but still trim the following line
	            while (src[i + 1] === ' ' || src[i + 1] === '\t') i += 1;

	            break;

	          default:
	            errors.push(new PlainValueEc8e588e.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
	            str += '\\' + src[i];
	        }
	      } else if (ch === ' ' || ch === '\t') {
	        // trim trailing whitespace
	        const wsStart = i;
	        let next = src[i + 1];

	        while (next === ' ' || next === '\t') {
	          i += 1;
	          next = src[i + 1];
	        }

	        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
	      } else {
	        str += ch;
	      }
	    }

	    return errors.length > 0 ? {
	      errors,
	      str
	    } : str;
	  }

	  parseCharCode(offset, length, errors) {
	    const {
	      src
	    } = this.context;
	    const cc = src.substr(offset, length);
	    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
	    const code = ok ? parseInt(cc, 16) : NaN;

	    if (isNaN(code)) {
	      errors.push(new PlainValueEc8e588e.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
	      return src.substr(offset - 2, length + 2);
	    }

	    return String.fromCodePoint(code);
	  }
	  /**
	   * Parses a "double quoted" value from the source
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this scalar
	   */


	  parse(context, start) {
	    this.context = context;
	    const {
	      src
	    } = context;
	    let offset = QuoteDouble.endOfQuote(src, start + 1);
	    this.valueRange = new PlainValueEc8e588e.Range(start, offset);
	    offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	    offset = this.parseComment(offset);
	    return offset;
	  }

	}

	class QuoteSingle extends PlainValueEc8e588e.Node {
	  static endOfQuote(src, offset) {
	    let ch = src[offset];

	    while (ch) {
	      if (ch === "'") {
	        if (src[offset + 1] !== "'") break;
	        ch = src[offset += 2];
	      } else {
	        ch = src[offset += 1];
	      }
	    }

	    return offset + 1;
	  }
	  /**
	   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
	   */


	  get strValue() {
	    if (!this.valueRange || !this.context) return null;
	    const errors = [];
	    const {
	      start,
	      end
	    } = this.valueRange;
	    const {
	      indent,
	      src
	    } = this.context;
	    if (src[end - 1] !== "'") errors.push(new PlainValueEc8e588e.YAMLSyntaxError(this, "Missing closing 'quote"));
	    let str = '';

	    for (let i = start + 1; i < end - 1; ++i) {
	      const ch = src[i];

	      if (ch === '\n') {
	        if (PlainValueEc8e588e.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValueEc8e588e.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
	        const {
	          fold,
	          offset,
	          error
	        } = PlainValueEc8e588e.Node.foldNewline(src, i, indent);
	        str += fold;
	        i = offset;
	        if (error) errors.push(new PlainValueEc8e588e.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
	      } else if (ch === "'") {
	        str += ch;
	        i += 1;
	        if (src[i] !== "'") errors.push(new PlainValueEc8e588e.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
	      } else if (ch === ' ' || ch === '\t') {
	        // trim trailing whitespace
	        const wsStart = i;
	        let next = src[i + 1];

	        while (next === ' ' || next === '\t') {
	          i += 1;
	          next = src[i + 1];
	        }

	        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
	      } else {
	        str += ch;
	      }
	    }

	    return errors.length > 0 ? {
	      errors,
	      str
	    } : str;
	  }
	  /**
	   * Parses a 'single quoted' value from the source
	   *
	   * @param {ParseContext} context
	   * @param {number} start - Index of first character
	   * @returns {number} - Index of the character after this scalar
	   */


	  parse(context, start) {
	    this.context = context;
	    const {
	      src
	    } = context;
	    let offset = QuoteSingle.endOfQuote(src, start + 1);
	    this.valueRange = new PlainValueEc8e588e.Range(start, offset);
	    offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	    offset = this.parseComment(offset);
	    return offset;
	  }

	}

	function createNewNode(type, props) {
	  switch (type) {
	    case PlainValueEc8e588e.Type.ALIAS:
	      return new Alias(type, props);

	    case PlainValueEc8e588e.Type.BLOCK_FOLDED:
	    case PlainValueEc8e588e.Type.BLOCK_LITERAL:
	      return new BlockValue(type, props);

	    case PlainValueEc8e588e.Type.FLOW_MAP:
	    case PlainValueEc8e588e.Type.FLOW_SEQ:
	      return new FlowCollection(type, props);

	    case PlainValueEc8e588e.Type.MAP_KEY:
	    case PlainValueEc8e588e.Type.MAP_VALUE:
	    case PlainValueEc8e588e.Type.SEQ_ITEM:
	      return new CollectionItem(type, props);

	    case PlainValueEc8e588e.Type.COMMENT:
	    case PlainValueEc8e588e.Type.PLAIN:
	      return new PlainValueEc8e588e.PlainValue(type, props);

	    case PlainValueEc8e588e.Type.QUOTE_DOUBLE:
	      return new QuoteDouble(type, props);

	    case PlainValueEc8e588e.Type.QUOTE_SINGLE:
	      return new QuoteSingle(type, props);

	    /* istanbul ignore next */

	    default:
	      return null;
	    // should never happen
	  }
	}
	/**
	 * @param {boolean} atLineStart - Node starts at beginning of line
	 * @param {boolean} inFlow - true if currently in a flow context
	 * @param {boolean} inCollection - true if currently in a collection context
	 * @param {number} indent - Current level of indentation
	 * @param {number} lineStart - Start of the current line
	 * @param {Node} parent - The parent of the node
	 * @param {string} src - Source of the YAML document
	 */


	class ParseContext {
	  static parseType(src, offset, inFlow) {
	    switch (src[offset]) {
	      case '*':
	        return PlainValueEc8e588e.Type.ALIAS;

	      case '>':
	        return PlainValueEc8e588e.Type.BLOCK_FOLDED;

	      case '|':
	        return PlainValueEc8e588e.Type.BLOCK_LITERAL;

	      case '{':
	        return PlainValueEc8e588e.Type.FLOW_MAP;

	      case '[':
	        return PlainValueEc8e588e.Type.FLOW_SEQ;

	      case '?':
	        return !inFlow && PlainValueEc8e588e.Node.atBlank(src, offset + 1, true) ? PlainValueEc8e588e.Type.MAP_KEY : PlainValueEc8e588e.Type.PLAIN;

	      case ':':
	        return !inFlow && PlainValueEc8e588e.Node.atBlank(src, offset + 1, true) ? PlainValueEc8e588e.Type.MAP_VALUE : PlainValueEc8e588e.Type.PLAIN;

	      case '-':
	        return !inFlow && PlainValueEc8e588e.Node.atBlank(src, offset + 1, true) ? PlainValueEc8e588e.Type.SEQ_ITEM : PlainValueEc8e588e.Type.PLAIN;

	      case '"':
	        return PlainValueEc8e588e.Type.QUOTE_DOUBLE;

	      case "'":
	        return PlainValueEc8e588e.Type.QUOTE_SINGLE;

	      default:
	        return PlainValueEc8e588e.Type.PLAIN;
	    }
	  }

	  constructor(orig = {}, {
	    atLineStart,
	    inCollection,
	    inFlow,
	    indent,
	    lineStart,
	    parent
	  } = {}) {
	    PlainValueEc8e588e._defineProperty(this, "parseNode", (overlay, start) => {
	      if (PlainValueEc8e588e.Node.atDocumentBoundary(this.src, start)) return null;
	      const context = new ParseContext(this, overlay);
	      const {
	        props,
	        type,
	        valueStart
	      } = context.parseProps(start);
	      const node = createNewNode(type, props);
	      let offset = node.parse(context, valueStart);
	      node.range = new PlainValueEc8e588e.Range(start, offset);
	      /* istanbul ignore if */

	      if (offset <= start) {
	        // This should never happen, but if it does, let's make sure to at least
	        // step one character forward to avoid a busy loop.
	        node.error = new Error(`Node#parse consumed no characters`);
	        node.error.parseEnd = offset;
	        node.error.source = node;
	        node.range.end = start + 1;
	      }

	      if (context.nodeStartsCollection(node)) {
	        if (!node.error && !context.atLineStart && context.parent.type === PlainValueEc8e588e.Type.DOCUMENT) {
	          node.error = new PlainValueEc8e588e.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
	        }

	        const collection = new Collection(node);
	        offset = collection.parse(new ParseContext(context), offset);
	        collection.range = new PlainValueEc8e588e.Range(start, offset);
	        return collection;
	      }

	      return node;
	    });

	    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
	    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
	    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
	    this.indent = indent != null ? indent : orig.indent;
	    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
	    this.parent = parent != null ? parent : orig.parent || {};
	    this.root = orig.root;
	    this.src = orig.src;
	  }

	  nodeStartsCollection(node) {
	    const {
	      inCollection,
	      inFlow,
	      src
	    } = this;
	    if (inCollection || inFlow) return false;
	    if (node instanceof CollectionItem) return true; // check for implicit key

	    let offset = node.range.end;
	    if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
	    offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	    return src[offset] === ':';
	  } // Anchor and tag are before type, which determines the node implementation
	  // class; hence this intermediate step.


	  parseProps(offset) {
	    const {
	      inFlow,
	      parent,
	      src
	    } = this;
	    const props = [];
	    let lineHasProps = false;
	    offset = this.atLineStart ? PlainValueEc8e588e.Node.endOfIndent(src, offset) : PlainValueEc8e588e.Node.endOfWhiteSpace(src, offset);
	    let ch = src[offset];

	    while (ch === PlainValueEc8e588e.Char.ANCHOR || ch === PlainValueEc8e588e.Char.COMMENT || ch === PlainValueEc8e588e.Char.TAG || ch === '\n') {
	      if (ch === '\n') {
	        const lineStart = offset + 1;
	        const inEnd = PlainValueEc8e588e.Node.endOfIndent(src, lineStart);
	        const indentDiff = inEnd - (lineStart + this.indent);
	        const noIndicatorAsIndent = parent.type === PlainValueEc8e588e.Type.SEQ_ITEM && parent.context.atLineStart;
	        if (!PlainValueEc8e588e.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
	        this.atLineStart = true;
	        this.lineStart = lineStart;
	        lineHasProps = false;
	        offset = inEnd;
	      } else if (ch === PlainValueEc8e588e.Char.COMMENT) {
	        const end = PlainValueEc8e588e.Node.endOfLine(src, offset + 1);
	        props.push(new PlainValueEc8e588e.Range(offset, end));
	        offset = end;
	      } else {
	        let end = PlainValueEc8e588e.Node.endOfIdentifier(src, offset + 1);

	        if (ch === PlainValueEc8e588e.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
	          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
	          // than an empty but 'foo.bar' private-tagged node in a flow collection
	          // followed without whitespace by a plain string starting with a year
	          // or date divided by something.
	          end = PlainValueEc8e588e.Node.endOfIdentifier(src, end + 5);
	        }

	        props.push(new PlainValueEc8e588e.Range(offset, end));
	        lineHasProps = true;
	        offset = PlainValueEc8e588e.Node.endOfWhiteSpace(src, end);
	      }

	      ch = src[offset];
	    } // '- &a : b' has an anchor on an empty node


	    if (lineHasProps && ch === ':' && PlainValueEc8e588e.Node.atBlank(src, offset + 1, true)) offset -= 1;
	    const type = ParseContext.parseType(src, offset, inFlow);
	    return {
	      props,
	      type,
	      valueStart: offset
	    };
	  }
	  /**
	   * Parses a node from the source
	   * @param {ParseContext} overlay
	   * @param {number} start - Index of first non-whitespace character for the node
	   * @returns {?Node} - null if at a document boundary
	   */


	}

	// Published as 'yaml/parse-cst'
	function parse(src) {
	  const cr = [];

	  if (src.indexOf('\r') !== -1) {
	    src = src.replace(/\r\n?/g, (match, offset) => {
	      if (match.length > 1) cr.push(offset);
	      return '\n';
	    });
	  }

	  const documents = [];
	  let offset = 0;

	  do {
	    const doc = new Document();
	    const context = new ParseContext({
	      src
	    });
	    offset = doc.parse(context, offset);
	    documents.push(doc);
	  } while (offset < src.length);

	  documents.setOrigRanges = () => {
	    if (cr.length === 0) return false;

	    for (let i = 1; i < cr.length; ++i) cr[i] -= i;

	    let crOffset = 0;

	    for (let i = 0; i < documents.length; ++i) {
	      crOffset = documents[i].setOrigRanges(cr, crOffset);
	    }

	    cr.splice(0, cr.length);
	    return true;
	  };

	  documents.toString = () => documents.join('...\n');

	  return documents;
	}

	var parse_1 = parse;

	var parseCst = {
		parse: parse_1
	};

	function addCommentBefore(str, indent, comment) {
	  if (!comment) return str;
	  const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
	  return `#${cc}\n${indent}${str}`;
	}
	function addComment(str, indent, comment) {
	  return !comment ? str : comment.indexOf('\n') === -1 ? `${str} #${comment}` : `${str}\n` + comment.replace(/^/gm, `${indent || ''}#`);
	}

	class Node$1 {}

	function toJSON(value, arg, ctx) {
	  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));

	  if (value && typeof value.toJSON === 'function') {
	    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
	    if (anchor) ctx.onCreate = res => {
	      anchor.res = res;
	      delete ctx.onCreate;
	    };
	    const res = value.toJSON(arg, ctx);
	    if (anchor && ctx.onCreate) ctx.onCreate(res);
	    return res;
	  }

	  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
	  return value;
	}

	class Scalar extends Node$1 {
	  constructor(value) {
	    super();
	    this.value = value;
	  }

	  toJSON(arg, ctx) {
	    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
	  }

	  toString() {
	    return String(this.value);
	  }

	}

	function collectionFromPath(schema, path, value) {
	  let v = value;

	  for (let i = path.length - 1; i >= 0; --i) {
	    const k = path[i];
	    const o = Number.isInteger(k) && k >= 0 ? [] : {};
	    o[k] = v;
	    v = o;
	  }

	  return schema.createNode(v, false);
	} // null, undefined, or an empty non-string iterable (e.g. [])


	const isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;
	class Collection$1 extends Node$1 {
	  constructor(schema) {
	    super();

	    PlainValueEc8e588e._defineProperty(this, "items", []);

	    this.schema = schema;
	  }

	  addIn(path, value) {
	    if (isEmptyPath(path)) this.add(value);else {
	      const [key, ...rest] = path;
	      const node = this.get(key, true);
	      if (node instanceof Collection$1) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
	    }
	  }

	  deleteIn([key, ...rest]) {
	    if (rest.length === 0) return this.delete(key);
	    const node = this.get(key, true);
	    if (node instanceof Collection$1) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
	  }

	  getIn([key, ...rest], keepScalar) {
	    const node = this.get(key, true);
	    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection$1 ? node.getIn(rest, keepScalar) : undefined;
	  }

	  hasAllNullValues() {
	    return this.items.every(node => {
	      if (!node || node.type !== 'PAIR') return false;
	      const n = node.value;
	      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
	    });
	  }

	  hasIn([key, ...rest]) {
	    if (rest.length === 0) return this.has(key);
	    const node = this.get(key, true);
	    return node instanceof Collection$1 ? node.hasIn(rest) : false;
	  }

	  setIn([key, ...rest], value) {
	    if (rest.length === 0) {
	      this.set(key, value);
	    } else {
	      const node = this.get(key, true);
	      if (node instanceof Collection$1) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
	    }
	  } // overridden in implementations

	  /* istanbul ignore next */


	  toJSON() {
	    return null;
	  }

	  toString(ctx, {
	    blockItem,
	    flowChars,
	    isMap,
	    itemIndent
	  }, onComment, onChompKeep) {
	    const {
	      indent,
	      indentStep,
	      stringify
	    } = ctx;
	    const inFlow = this.type === PlainValueEc8e588e.Type.FLOW_MAP || this.type === PlainValueEc8e588e.Type.FLOW_SEQ || ctx.inFlow;
	    if (inFlow) itemIndent += indentStep;
	    const allNullValues = isMap && this.hasAllNullValues();
	    ctx = Object.assign({}, ctx, {
	      allNullValues,
	      indent: itemIndent,
	      inFlow,
	      type: null
	    });
	    let chompKeep = false;
	    let hasItemWithNewLine = false;
	    const nodes = this.items.reduce((nodes, item, i) => {
	      let comment;

	      if (item) {
	        if (!chompKeep && item.spaceBefore) nodes.push({
	          type: 'comment',
	          str: ''
	        });
	        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {
	          nodes.push({
	            type: 'comment',
	            str: `#${line}`
	          });
	        });
	        if (item.comment) comment = item.comment;
	        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
	      }

	      chompKeep = false;
	      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);
	      if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
	      if (inFlow && i < this.items.length - 1) str += ',';
	      str = addComment(str, itemIndent, comment);
	      if (chompKeep && (comment || inFlow)) chompKeep = false;
	      nodes.push({
	        type: 'item',
	        str
	      });
	      return nodes;
	    }, []);
	    let str;

	    if (nodes.length === 0) {
	      str = flowChars.start + flowChars.end;
	    } else if (inFlow) {
	      const {
	        start,
	        end
	      } = flowChars;
	      const strings = nodes.map(n => n.str);

	      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection$1.maxFlowStringSingleLineLength) {
	        str = start;

	        for (const s of strings) {
	          str += s ? `\n${indentStep}${indent}${s}` : '\n';
	        }

	        str += `\n${indent}${end}`;
	      } else {
	        str = `${start} ${strings.join(' ')} ${end}`;
	      }
	    } else {
	      const strings = nodes.map(blockItem);
	      str = strings.shift();

	      for (const s of strings) str += s ? `\n${indent}${s}` : '\n';
	    }

	    if (this.comment) {
	      str += '\n' + this.comment.replace(/^/gm, `${indent}#`);
	      if (onComment) onComment();
	    } else if (chompKeep && onChompKeep) onChompKeep();

	    return str;
	  }

	}

	PlainValueEc8e588e._defineProperty(Collection$1, "maxFlowStringSingleLineLength", 60);

	function asItemIndex(key) {
	  let idx = key instanceof Scalar ? key.value : key;
	  if (idx && typeof idx === 'string') idx = Number(idx);
	  return Number.isInteger(idx) && idx >= 0 ? idx : null;
	}

	class YAMLSeq extends Collection$1 {
	  add(value) {
	    this.items.push(value);
	  }

	  delete(key) {
	    const idx = asItemIndex(key);
	    if (typeof idx !== 'number') return false;
	    const del = this.items.splice(idx, 1);
	    return del.length > 0;
	  }

	  get(key, keepScalar) {
	    const idx = asItemIndex(key);
	    if (typeof idx !== 'number') return undefined;
	    const it = this.items[idx];
	    return !keepScalar && it instanceof Scalar ? it.value : it;
	  }

	  has(key) {
	    const idx = asItemIndex(key);
	    return typeof idx === 'number' && idx < this.items.length;
	  }

	  set(key, value) {
	    const idx = asItemIndex(key);
	    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
	    this.items[idx] = value;
	  }

	  toJSON(_, ctx) {
	    const seq = [];
	    if (ctx && ctx.onCreate) ctx.onCreate(seq);
	    let i = 0;

	    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));

	    return seq;
	  }

	  toString(ctx, onComment, onChompKeep) {
	    if (!ctx) return JSON.stringify(this);
	    return super.toString(ctx, {
	      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,
	      flowChars: {
	        start: '[',
	        end: ']'
	      },
	      isMap: false,
	      itemIndent: (ctx.indent || '') + '  '
	    }, onComment, onChompKeep);
	  }

	}

	const stringifyKey = (key, jsKey, ctx) => {
	  if (jsKey === null) return '';
	  if (typeof jsKey !== 'object') return String(jsKey);
	  if (key instanceof Node$1 && ctx && ctx.doc) return key.toString({
	    anchors: {},
	    doc: ctx.doc,
	    indent: '',
	    indentStep: ctx.indentStep,
	    inFlow: true,
	    inStringifyKey: true,
	    stringify: ctx.stringify
	  });
	  return JSON.stringify(jsKey);
	};

	class Pair extends Node$1 {
	  constructor(key, value = null) {
	    super();
	    this.key = key;
	    this.value = value;
	    this.type = Pair.Type.PAIR;
	  }

	  get commentBefore() {
	    return this.key instanceof Node$1 ? this.key.commentBefore : undefined;
	  }

	  set commentBefore(cb) {
	    if (this.key == null) this.key = new Scalar(null);
	    if (this.key instanceof Node$1) this.key.commentBefore = cb;else {
	      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';
	      throw new Error(msg);
	    }
	  }

	  addToJSMap(ctx, map) {
	    const key = toJSON(this.key, '', ctx);

	    if (map instanceof Map) {
	      const value = toJSON(this.value, key, ctx);
	      map.set(key, value);
	    } else if (map instanceof Set) {
	      map.add(key);
	    } else {
	      const stringKey = stringifyKey(this.key, key, ctx);
	      map[stringKey] = toJSON(this.value, stringKey, ctx);
	    }

	    return map;
	  }

	  toJSON(_, ctx) {
	    const pair = ctx && ctx.mapAsMap ? new Map() : {};
	    return this.addToJSMap(ctx, pair);
	  }

	  toString(ctx, onComment, onChompKeep) {
	    if (!ctx || !ctx.doc) return JSON.stringify(this);
	    const {
	      indent: indentSize,
	      indentSeq,
	      simpleKeys
	    } = ctx.doc.options;
	    let {
	      key,
	      value
	    } = this;
	    let keyComment = key instanceof Node$1 && key.comment;

	    if (simpleKeys) {
	      if (keyComment) {
	        throw new Error('With simple keys, key nodes cannot have comments');
	      }

	      if (key instanceof Collection$1) {
	        const msg = 'With simple keys, collection cannot be used as a key value';
	        throw new Error(msg);
	      }
	    }

	    const explicitKey = !simpleKeys && (!key || keyComment || key instanceof Collection$1 || key.type === PlainValueEc8e588e.Type.BLOCK_FOLDED || key.type === PlainValueEc8e588e.Type.BLOCK_LITERAL);
	    const {
	      doc,
	      indent,
	      indentStep,
	      stringify
	    } = ctx;
	    ctx = Object.assign({}, ctx, {
	      implicitKey: !explicitKey,
	      indent: indent + indentStep
	    });
	    let chompKeep = false;
	    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
	    str = addComment(str, ctx.indent, keyComment);

	    if (ctx.allNullValues && !simpleKeys) {
	      if (this.comment) {
	        str = addComment(str, ctx.indent, this.comment);
	        if (onComment) onComment();
	      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

	      return ctx.inFlow ? str : `? ${str}`;
	    }

	    str = explicitKey ? `? ${str}\n${indent}:` : `${str}:`;

	    if (this.comment) {
	      // expected (but not strictly required) to be a single-line comment
	      str = addComment(str, ctx.indent, this.comment);
	      if (onComment) onComment();
	    }

	    let vcb = '';
	    let valueComment = null;

	    if (value instanceof Node$1) {
	      if (value.spaceBefore) vcb = '\n';

	      if (value.commentBefore) {
	        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
	        vcb += `\n${cs}`;
	      }

	      valueComment = value.comment;
	    } else if (value && typeof value === 'object') {
	      value = doc.schema.createNode(value, true);
	    }

	    ctx.implicitKey = false;
	    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
	    chompKeep = false;

	    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValueEc8e588e.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
	      // If indentSeq === false, consider '- ' as part of indentation where possible
	      ctx.indent = ctx.indent.substr(2);
	    }

	    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
	    let ws = ' ';

	    if (vcb || this.comment) {
	      ws = `${vcb}\n${ctx.indent}`;
	    } else if (!explicitKey && value instanceof Collection$1) {
	      const flow = valueStr[0] === '[' || valueStr[0] === '{';
	      if (!flow || valueStr.includes('\n')) ws = `\n${ctx.indent}`;
	    }

	    if (chompKeep && !valueComment && onChompKeep) onChompKeep();
	    return addComment(str + ws + valueStr, ctx.indent, valueComment);
	  }

	}

	PlainValueEc8e588e._defineProperty(Pair, "Type", {
	  PAIR: 'PAIR',
	  MERGE_PAIR: 'MERGE_PAIR'
	});

	const getAliasCount = (node, anchors) => {
	  if (node instanceof Alias$1) {
	    const anchor = anchors.get(node.source);
	    return anchor.count * anchor.aliasCount;
	  } else if (node instanceof Collection$1) {
	    let count = 0;

	    for (const item of node.items) {
	      const c = getAliasCount(item, anchors);
	      if (c > count) count = c;
	    }

	    return count;
	  } else if (node instanceof Pair) {
	    const kc = getAliasCount(node.key, anchors);
	    const vc = getAliasCount(node.value, anchors);
	    return Math.max(kc, vc);
	  }

	  return 1;
	};

	class Alias$1 extends Node$1 {
	  static stringify({
	    range,
	    source
	  }, {
	    anchors,
	    doc,
	    implicitKey,
	    inStringifyKey
	  }) {
	    let anchor = Object.keys(anchors).find(a => anchors[a] === source);
	    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
	    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;
	    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
	    throw new Error(`${msg} [${range}]`);
	  }

	  constructor(source) {
	    super();
	    this.source = source;
	    this.type = PlainValueEc8e588e.Type.ALIAS;
	  }

	  set tag(t) {
	    throw new Error('Alias nodes cannot have tags');
	  }

	  toJSON(arg, ctx) {
	    if (!ctx) return toJSON(this.source, arg, ctx);
	    const {
	      anchors,
	      maxAliasCount
	    } = ctx;
	    const anchor = anchors.get(this.source);
	    /* istanbul ignore if */

	    if (!anchor || anchor.res === undefined) {
	      const msg = 'This should not happen: Alias anchor was not resolved?';
	      if (this.cstNode) throw new PlainValueEc8e588e.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
	    }

	    if (maxAliasCount >= 0) {
	      anchor.count += 1;
	      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

	      if (anchor.count * anchor.aliasCount > maxAliasCount) {
	        const msg = 'Excessive alias count indicates a resource exhaustion attack';
	        if (this.cstNode) throw new PlainValueEc8e588e.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
	      }
	    }

	    return anchor.res;
	  } // Only called when stringifying an alias mapping key while constructing
	  // Object output.


	  toString(ctx) {
	    return Alias$1.stringify(this, ctx);
	  }

	}

	PlainValueEc8e588e._defineProperty(Alias$1, "default", true);

	function findPair(items, key) {
	  const k = key instanceof Scalar ? key.value : key;

	  for (const it of items) {
	    if (it instanceof Pair) {
	      if (it.key === key || it.key === k) return it;
	      if (it.key && it.key.value === k) return it;
	    }
	  }

	  return undefined;
	}
	class YAMLMap extends Collection$1 {
	  add(pair, overwrite) {
	    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
	    const prev = findPair(this.items, pair.key);
	    const sortEntries = this.schema && this.schema.sortMapEntries;

	    if (prev) {
	      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);
	    } else if (sortEntries) {
	      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);
	      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);
	    } else {
	      this.items.push(pair);
	    }
	  }

	  delete(key) {
	    const it = findPair(this.items, key);
	    if (!it) return false;
	    const del = this.items.splice(this.items.indexOf(it), 1);
	    return del.length > 0;
	  }

	  get(key, keepScalar) {
	    const it = findPair(this.items, key);
	    const node = it && it.value;
	    return !keepScalar && node instanceof Scalar ? node.value : node;
	  }

	  has(key) {
	    return !!findPair(this.items, key);
	  }

	  set(key, value) {
	    this.add(new Pair(key, value), true);
	  }
	  /**
	   * @param {*} arg ignored
	   * @param {*} ctx Conversion context, originally set in Document#toJSON()
	   * @param {Class} Type If set, forces the returned collection type
	   * @returns {*} Instance of Type, Map, or Object
	   */


	  toJSON(_, ctx, Type) {
	    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
	    if (ctx && ctx.onCreate) ctx.onCreate(map);

	    for (const item of this.items) item.addToJSMap(ctx, map);

	    return map;
	  }

	  toString(ctx, onComment, onChompKeep) {
	    if (!ctx) return JSON.stringify(this);

	    for (const item of this.items) {
	      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
	    }

	    return super.toString(ctx, {
	      blockItem: n => n.str,
	      flowChars: {
	        start: '{',
	        end: '}'
	      },
	      isMap: true,
	      itemIndent: ctx.indent || ''
	    }, onComment, onChompKeep);
	  }

	}

	const MERGE_KEY = '<<';
	class Merge extends Pair {
	  constructor(pair) {
	    if (pair instanceof Pair) {
	      let seq = pair.value;

	      if (!(seq instanceof YAMLSeq)) {
	        seq = new YAMLSeq();
	        seq.items.push(pair.value);
	        seq.range = pair.value.range;
	      }

	      super(pair.key, seq);
	      this.range = pair.range;
	    } else {
	      super(new Scalar(MERGE_KEY), new YAMLSeq());
	    }

	    this.type = Pair.Type.MERGE_PAIR;
	  } // If the value associated with a merge key is a single mapping node, each of
	  // its key/value pairs is inserted into the current mapping, unless the key
	  // already exists in it. If the value associated with the merge key is a
	  // sequence, then this sequence is expected to contain mapping nodes and each
	  // of these nodes is merged in turn according to its order in the sequence.
	  // Keys in mapping nodes earlier in the sequence override keys specified in
	  // later mapping nodes. -- http://yaml.org/type/merge.html


	  addToJSMap(ctx, map) {
	    for (const {
	      source
	    } of this.value.items) {
	      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');
	      const srcMap = source.toJSON(null, ctx, Map);

	      for (const [key, value] of srcMap) {
	        if (map instanceof Map) {
	          if (!map.has(key)) map.set(key, value);
	        } else if (map instanceof Set) {
	          map.add(key);
	        } else {
	          if (!Object.prototype.hasOwnProperty.call(map, key)) map[key] = value;
	        }
	      }
	    }

	    return map;
	  }

	  toString(ctx, onComment) {
	    const seq = this.value;
	    if (seq.items.length > 1) return super.toString(ctx, onComment);
	    this.value = seq.items[0];
	    const str = super.toString(ctx, onComment);
	    this.value = seq;
	    return str;
	  }

	}

	const binaryOptions = {
	  defaultType: PlainValueEc8e588e.Type.BLOCK_LITERAL,
	  lineWidth: 76
	};
	const boolOptions = {
	  trueStr: 'true',
	  falseStr: 'false'
	};
	const intOptions = {
	  asBigInt: false
	};
	const nullOptions = {
	  nullStr: 'null'
	};
	const strOptions = {
	  defaultType: PlainValueEc8e588e.Type.PLAIN,
	  doubleQuoted: {
	    jsonEncoding: false,
	    minMultiLineLength: 40
	  },
	  fold: {
	    lineWidth: 80,
	    minContentWidth: 20
	  }
	};

	function resolveScalar(str, tags, scalarFallback) {
	  for (const {
	    format,
	    test,
	    resolve
	  } of tags) {
	    if (test) {
	      const match = str.match(test);

	      if (match) {
	        let res = resolve.apply(null, match);
	        if (!(res instanceof Scalar)) res = new Scalar(res);
	        if (format) res.format = format;
	        return res;
	      }
	    }
	  }

	  if (scalarFallback) str = scalarFallback(str);
	  return new Scalar(str);
	}

	const FOLD_FLOW = 'flow';
	const FOLD_BLOCK = 'block';
	const FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
	// returns index of last newline in more-indented block

	const consumeMoreIndentedLines = (text, i) => {
	  let ch = text[i + 1];

	  while (ch === ' ' || ch === '\t') {
	    do {
	      ch = text[i += 1];
	    } while (ch && ch !== '\n');

	    ch = text[i + 1];
	  }

	  return i;
	};
	/**
	 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
	 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
	 * terminated with `\n` and started with `indent`.
	 *
	 * @param {string} text
	 * @param {string} indent
	 * @param {string} [mode='flow'] `'block'` prevents more-indented lines
	 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
	 *   newlines
	 * @param {Object} options
	 * @param {number} [options.indentAtStart] Accounts for leading contents on
	 *   the first line, defaulting to `indent.length`
	 * @param {number} [options.lineWidth=80]
	 * @param {number} [options.minContentWidth=20] Allow highly indented lines to
	 *   stretch the line width
	 * @param {function} options.onFold Called once if the text is folded
	 * @param {function} options.onFold Called once if any line of text exceeds
	 *   lineWidth characters
	 */


	function foldFlowLines(text, indent, mode, {
	  indentAtStart,
	  lineWidth = 80,
	  minContentWidth = 20,
	  onFold,
	  onOverflow
	}) {
	  if (!lineWidth || lineWidth < 0) return text;
	  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
	  if (text.length <= endStep) return text;
	  const folds = [];
	  const escapedFolds = {};
	  let end = lineWidth - (typeof indentAtStart === 'number' ? indentAtStart : indent.length);
	  let split = undefined;
	  let prev = undefined;
	  let overflow = false;
	  let i = -1;

	  if (mode === FOLD_BLOCK) {
	    i = consumeMoreIndentedLines(text, i);
	    if (i !== -1) end = i + endStep;
	  }

	  for (let ch; ch = text[i += 1];) {
	    if (mode === FOLD_QUOTED && ch === '\\') {
	      switch (text[i + 1]) {
	        case 'x':
	          i += 3;
	          break;

	        case 'u':
	          i += 5;
	          break;

	        case 'U':
	          i += 9;
	          break;

	        default:
	          i += 1;
	      }
	    }

	    if (ch === '\n') {
	      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
	      end = i + endStep;
	      split = undefined;
	    } else {
	      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
	        // space surrounded by non-space can be replaced with newline + indent
	        const next = text[i + 1];
	        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
	      }

	      if (i >= end) {
	        if (split) {
	          folds.push(split);
	          end = split + endStep;
	          split = undefined;
	        } else if (mode === FOLD_QUOTED) {
	          // white-space collected at end may stretch past lineWidth
	          while (prev === ' ' || prev === '\t') {
	            prev = ch;
	            ch = text[i += 1];
	            overflow = true;
	          } // i - 2 accounts for not-dropped last char + newline-escaping \


	          folds.push(i - 2);
	          escapedFolds[i - 2] = true;
	          end = i - 2 + endStep;
	          split = undefined;
	        } else {
	          overflow = true;
	        }
	      }
	    }

	    prev = ch;
	  }

	  if (overflow && onOverflow) onOverflow();
	  if (folds.length === 0) return text;
	  if (onFold) onFold();
	  let res = text.slice(0, folds[0]);

	  for (let i = 0; i < folds.length; ++i) {
	    const fold = folds[i];
	    const end = folds[i + 1] || text.length;
	    if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
	    res += `\n${indent}${text.slice(fold + 1, end)}`;
	  }

	  return res;
	}

	const getFoldOptions = ({
	  indentAtStart
	}) => indentAtStart ? Object.assign({
	  indentAtStart
	}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
	// presume that's starting a new document.


	const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);

	function lineLengthOverLimit(str, limit) {
	  const strLen = str.length;
	  if (strLen <= limit) return false;

	  for (let i = 0, start = 0; i < strLen; ++i) {
	    if (str[i] === '\n') {
	      if (i - start > limit) return true;
	      start = i + 1;
	      if (strLen - start <= limit) return false;
	    }
	  }

	  return true;
	}

	function doubleQuotedString(value, ctx) {
	  const {
	    implicitKey
	  } = ctx;
	  const {
	    jsonEncoding,
	    minMultiLineLength
	  } = strOptions.doubleQuoted;
	  const json = JSON.stringify(value);
	  if (jsonEncoding) return json;
	  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
	  let str = '';
	  let start = 0;

	  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
	    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
	      // space before newline needs to be escaped to not be folded
	      str += json.slice(start, i) + '\\ ';
	      i += 1;
	      start = i;
	      ch = '\\';
	    }

	    if (ch === '\\') switch (json[i + 1]) {
	      case 'u':
	        {
	          str += json.slice(start, i);
	          const code = json.substr(i + 2, 4);

	          switch (code) {
	            case '0000':
	              str += '\\0';
	              break;

	            case '0007':
	              str += '\\a';
	              break;

	            case '000b':
	              str += '\\v';
	              break;

	            case '001b':
	              str += '\\e';
	              break;

	            case '0085':
	              str += '\\N';
	              break;

	            case '00a0':
	              str += '\\_';
	              break;

	            case '2028':
	              str += '\\L';
	              break;

	            case '2029':
	              str += '\\P';
	              break;

	            default:
	              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
	          }

	          i += 5;
	          start = i + 1;
	        }
	        break;

	      case 'n':
	        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
	          i += 1;
	        } else {
	          // folding will eat first newline
	          str += json.slice(start, i) + '\n\n';

	          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
	            str += '\n';
	            i += 2;
	          }

	          str += indent; // space after newline needs to be escaped to not be folded

	          if (json[i + 2] === ' ') str += '\\';
	          i += 1;
	          start = i + 1;
	        }

	        break;

	      default:
	        i += 1;
	    }
	  }

	  str = start ? str + json.slice(start) : json;
	  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
	}

	function singleQuotedString(value, ctx) {
	  if (ctx.implicitKey) {
	    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
	  } else {
	    // single quoted string can't have leading or trailing whitespace around newline
	    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
	  }

	  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
	  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
	  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
	}

	function blockString({
	  comment,
	  type,
	  value
	}, ctx, onComment, onChompKeep) {
	  // 1. Block can't end in whitespace unless the last line is non-empty.
	  // 2. Strings consisting of only whitespace are best rendered explicitly.
	  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
	    return doubleQuotedString(value, ctx);
	  }

	  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
	  const indentSize = indent ? '2' : '1'; // root is at -1

	  const literal = type === PlainValueEc8e588e.Type.BLOCK_FOLDED ? false : type === PlainValueEc8e588e.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth - indent.length);
	  let header = literal ? '|' : '>';
	  if (!value) return header + '\n';
	  let wsStart = '';
	  let wsEnd = '';
	  value = value.replace(/[\n\t ]*$/, ws => {
	    const n = ws.indexOf('\n');

	    if (n === -1) {
	      header += '-'; // strip
	    } else if (value === ws || n !== ws.length - 1) {
	      header += '+'; // keep

	      if (onChompKeep) onChompKeep();
	    }

	    wsEnd = ws.replace(/\n$/, '');
	    return '';
	  }).replace(/^[\n ]*/, ws => {
	    if (ws.indexOf(' ') !== -1) header += indentSize;
	    const m = ws.match(/ +$/);

	    if (m) {
	      wsStart = ws.slice(0, -m[0].length);
	      return m[0];
	    } else {
	      wsStart = ws;
	      return '';
	    }
	  });
	  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
	  if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);

	  if (comment) {
	    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
	    if (onComment) onComment();
	  }

	  if (!value) return `${header}${indentSize}\n${indent}${wsEnd}`;

	  if (literal) {
	    value = value.replace(/\n+/g, `$&${indent}`);
	    return `${header}\n${indent}${wsStart}${value}${wsEnd}`;
	  }

	  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
	  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
	  .replace(/\n+/g, `$&${indent}`);
	  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
	  return `${header}\n${indent}${body}`;
	}

	function plainString(item, ctx, onComment, onChompKeep) {
	  const {
	    comment,
	    type,
	    value
	  } = item;
	  const {
	    actualString,
	    implicitKey,
	    indent,
	    inFlow
	  } = ctx;

	  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
	    return doubleQuotedString(value, ctx);
	  }

	  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
	    // not allowed:
	    // - empty string, '-' or '?'
	    // - start with an indicator character (except [?:-]) or /[?-] /
	    // - '\n ', ': ' or ' \n' anywhere
	    // - '#' not preceded by a non-space char
	    // - end with ' ' or ':'
	    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
	  }

	  if (!implicitKey && !inFlow && type !== PlainValueEc8e588e.Type.PLAIN && value.indexOf('\n') !== -1) {
	    // Where allowed & type not set explicitly, prefer block style for multiline strings
	    return blockString(item, ctx, onComment, onChompKeep);
	  }

	  if (indent === '' && containsDocumentMarker(value)) {
	    ctx.forceBlockIndent = true;
	    return blockString(item, ctx, onComment, onChompKeep);
	  }

	  const str = value.replace(/\n+/g, `$&\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and
	  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
	  // and others in v1.1.

	  if (actualString) {
	    const {
	      tags
	    } = ctx.doc.schema;
	    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
	    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);
	  }

	  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));

	  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
	    if (onComment) onComment();
	    return addCommentBefore(body, indent, comment);
	  }

	  return body;
	}

	function stringifyString(item, ctx, onComment, onChompKeep) {
	  const {
	    defaultType
	  } = strOptions;
	  const {
	    implicitKey,
	    inFlow
	  } = ctx;
	  let {
	    type,
	    value
	  } = item;

	  if (typeof value !== 'string') {
	    value = String(value);
	    item = Object.assign({}, item, {
	      value
	    });
	  }

	  const _stringify = _type => {
	    switch (_type) {
	      case PlainValueEc8e588e.Type.BLOCK_FOLDED:
	      case PlainValueEc8e588e.Type.BLOCK_LITERAL:
	        return blockString(item, ctx, onComment, onChompKeep);

	      case PlainValueEc8e588e.Type.QUOTE_DOUBLE:
	        return doubleQuotedString(value, ctx);

	      case PlainValueEc8e588e.Type.QUOTE_SINGLE:
	        return singleQuotedString(value, ctx);

	      case PlainValueEc8e588e.Type.PLAIN:
	        return plainString(item, ctx, onComment, onChompKeep);

	      default:
	        return null;
	    }
	  };

	  if (type !== PlainValueEc8e588e.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
	    // force double quotes on control characters
	    type = PlainValueEc8e588e.Type.QUOTE_DOUBLE;
	  } else if ((implicitKey || inFlow) && (type === PlainValueEc8e588e.Type.BLOCK_FOLDED || type === PlainValueEc8e588e.Type.BLOCK_LITERAL)) {
	    // should not happen; blocks are not valid inside flow containers
	    type = PlainValueEc8e588e.Type.QUOTE_DOUBLE;
	  }

	  let res = _stringify(type);

	  if (res === null) {
	    res = _stringify(defaultType);
	    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
	  }

	  return res;
	}

	function stringifyNumber({
	  format,
	  minFractionDigits,
	  tag,
	  value
	}) {
	  if (typeof value === 'bigint') return String(value);
	  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
	  let n = JSON.stringify(value);

	  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
	    let i = n.indexOf('.');

	    if (i < 0) {
	      i = n.length;
	      n += '.';
	    }

	    let d = minFractionDigits - (n.length - i - 1);

	    while (d-- > 0) n += '0';
	  }

	  return n;
	}

	function checkFlowCollectionEnd(errors, cst) {
	  let char, name;

	  switch (cst.type) {
	    case PlainValueEc8e588e.Type.FLOW_MAP:
	      char = '}';
	      name = 'flow map';
	      break;

	    case PlainValueEc8e588e.Type.FLOW_SEQ:
	      char = ']';
	      name = 'flow sequence';
	      break;

	    default:
	      errors.push(new PlainValueEc8e588e.YAMLSemanticError(cst, 'Not a flow collection!?'));
	      return;
	  }

	  let lastItem;

	  for (let i = cst.items.length - 1; i >= 0; --i) {
	    const item = cst.items[i];

	    if (!item || item.type !== PlainValueEc8e588e.Type.COMMENT) {
	      lastItem = item;
	      break;
	    }
	  }

	  if (lastItem && lastItem.char !== char) {
	    const msg = `Expected ${name} to end with ${char}`;
	    let err;

	    if (typeof lastItem.offset === 'number') {
	      err = new PlainValueEc8e588e.YAMLSemanticError(cst, msg);
	      err.offset = lastItem.offset + 1;
	    } else {
	      err = new PlainValueEc8e588e.YAMLSemanticError(lastItem, msg);
	      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
	    }

	    errors.push(err);
	  }
	}
	function checkFlowCommentSpace(errors, comment) {
	  const prev = comment.context.src[comment.range.start - 1];

	  if (prev !== '\n' && prev !== '\t' && prev !== ' ') {
	    const msg = 'Comments must be separated from other tokens by white space characters';
	    errors.push(new PlainValueEc8e588e.YAMLSemanticError(comment, msg));
	  }
	}
	function getLongKeyError(source, key) {
	  const sk = String(key);
	  const k = sk.substr(0, 8) + '...' + sk.substr(-8);
	  return new PlainValueEc8e588e.YAMLSemanticError(source, `The "${k}" key is too long`);
	}
	function resolveComments(collection, comments) {
	  for (const {
	    afterKey,
	    before,
	    comment
	  } of comments) {
	    let item = collection.items[before];

	    if (!item) {
	      if (comment !== undefined) {
	        if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
	      }
	    } else {
	      if (afterKey && item.value) item = item.value;

	      if (comment === undefined) {
	        if (afterKey || !item.commentBefore) item.spaceBefore = true;
	      } else {
	        if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
	      }
	    }
	  }
	}

	// on error, will return { str: string, errors: Error[] }
	function resolveString(doc, node) {
	  const res = node.strValue;
	  if (!res) return '';
	  if (typeof res === 'string') return res;
	  res.errors.forEach(error => {
	    if (!error.source) error.source = node;
	    doc.errors.push(error);
	  });
	  return res.str;
	}

	function resolveTagHandle(doc, node) {
	  const {
	    handle,
	    suffix
	  } = node.tag;
	  let prefix = doc.tagPrefixes.find(p => p.handle === handle);

	  if (!prefix) {
	    const dtp = doc.getDefaults().tagPrefixes;
	    if (dtp) prefix = dtp.find(p => p.handle === handle);
	    if (!prefix) throw new PlainValueEc8e588e.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
	  }

	  if (!suffix) throw new PlainValueEc8e588e.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);

	  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {
	    if (suffix[0] === '^') {
	      doc.warnings.push(new PlainValueEc8e588e.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));
	      return suffix;
	    }

	    if (/[:/]/.test(suffix)) {
	      // word/foo -> tag:word.yaml.org,2002:foo
	      const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
	      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
	    }
	  }

	  return prefix.prefix + decodeURIComponent(suffix);
	}

	function resolveTagName(doc, node) {
	  const {
	    tag,
	    type
	  } = node;
	  let nonSpecific = false;

	  if (tag) {
	    const {
	      handle,
	      suffix,
	      verbatim
	    } = tag;

	    if (verbatim) {
	      if (verbatim !== '!' && verbatim !== '!!') return verbatim;
	      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
	      doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(node, msg));
	    } else if (handle === '!' && !suffix) {
	      nonSpecific = true;
	    } else {
	      try {
	        return resolveTagHandle(doc, node);
	      } catch (error) {
	        doc.errors.push(error);
	      }
	    }
	  }

	  switch (type) {
	    case PlainValueEc8e588e.Type.BLOCK_FOLDED:
	    case PlainValueEc8e588e.Type.BLOCK_LITERAL:
	    case PlainValueEc8e588e.Type.QUOTE_DOUBLE:
	    case PlainValueEc8e588e.Type.QUOTE_SINGLE:
	      return PlainValueEc8e588e.defaultTags.STR;

	    case PlainValueEc8e588e.Type.FLOW_MAP:
	    case PlainValueEc8e588e.Type.MAP:
	      return PlainValueEc8e588e.defaultTags.MAP;

	    case PlainValueEc8e588e.Type.FLOW_SEQ:
	    case PlainValueEc8e588e.Type.SEQ:
	      return PlainValueEc8e588e.defaultTags.SEQ;

	    case PlainValueEc8e588e.Type.PLAIN:
	      return nonSpecific ? PlainValueEc8e588e.defaultTags.STR : null;

	    default:
	      return null;
	  }
	}

	function resolveByTagName(doc, node, tagName) {
	  const {
	    tags
	  } = doc.schema;
	  const matchWithTest = [];

	  for (const tag of tags) {
	    if (tag.tag === tagName) {
	      if (tag.test) matchWithTest.push(tag);else {
	        const res = tag.resolve(doc, node);
	        return res instanceof Collection$1 ? res : new Scalar(res);
	      }
	    }
	  }

	  const str = resolveString(doc, node);
	  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);
	  return null;
	}

	function getFallbackTagName({
	  type
	}) {
	  switch (type) {
	    case PlainValueEc8e588e.Type.FLOW_MAP:
	    case PlainValueEc8e588e.Type.MAP:
	      return PlainValueEc8e588e.defaultTags.MAP;

	    case PlainValueEc8e588e.Type.FLOW_SEQ:
	    case PlainValueEc8e588e.Type.SEQ:
	      return PlainValueEc8e588e.defaultTags.SEQ;

	    default:
	      return PlainValueEc8e588e.defaultTags.STR;
	  }
	}

	function resolveTag(doc, node, tagName) {
	  try {
	    const res = resolveByTagName(doc, node, tagName);

	    if (res) {
	      if (tagName && node.tag) res.tag = tagName;
	      return res;
	    }
	  } catch (error) {
	    /* istanbul ignore if */
	    if (!error.source) error.source = node;
	    doc.errors.push(error);
	    return null;
	  }

	  try {
	    const fallback = getFallbackTagName(node);
	    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
	    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
	    doc.warnings.push(new PlainValueEc8e588e.YAMLWarning(node, msg));
	    const res = resolveByTagName(doc, node, fallback);
	    res.tag = tagName;
	    return res;
	  } catch (error) {
	    const refError = new PlainValueEc8e588e.YAMLReferenceError(node, error.message);
	    refError.stack = error.stack;
	    doc.errors.push(refError);
	    return null;
	  }
	}

	const isCollectionItem = node => {
	  if (!node) return false;
	  const {
	    type
	  } = node;
	  return type === PlainValueEc8e588e.Type.MAP_KEY || type === PlainValueEc8e588e.Type.MAP_VALUE || type === PlainValueEc8e588e.Type.SEQ_ITEM;
	};

	function resolveNodeProps(errors, node) {
	  const comments = {
	    before: [],
	    after: []
	  };
	  let hasAnchor = false;
	  let hasTag = false;
	  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;

	  for (const {
	    start,
	    end
	  } of props) {
	    switch (node.context.src[start]) {
	      case PlainValueEc8e588e.Char.COMMENT:
	        {
	          if (!node.commentHasRequiredWhitespace(start)) {
	            const msg = 'Comments must be separated from other tokens by white space characters';
	            errors.push(new PlainValueEc8e588e.YAMLSemanticError(node, msg));
	          }

	          const {
	            header,
	            valueRange
	          } = node;
	          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
	          cc.push(node.context.src.slice(start + 1, end));
	          break;
	        }
	      // Actual anchor & tag resolution is handled by schema, here we just complain

	      case PlainValueEc8e588e.Char.ANCHOR:
	        if (hasAnchor) {
	          const msg = 'A node can have at most one anchor';
	          errors.push(new PlainValueEc8e588e.YAMLSemanticError(node, msg));
	        }

	        hasAnchor = true;
	        break;

	      case PlainValueEc8e588e.Char.TAG:
	        if (hasTag) {
	          const msg = 'A node can have at most one tag';
	          errors.push(new PlainValueEc8e588e.YAMLSemanticError(node, msg));
	        }

	        hasTag = true;
	        break;
	    }
	  }

	  return {
	    comments,
	    hasAnchor,
	    hasTag
	  };
	}

	function resolveNodeValue(doc, node) {
	  const {
	    anchors,
	    errors,
	    schema
	  } = doc;

	  if (node.type === PlainValueEc8e588e.Type.ALIAS) {
	    const name = node.rawValue;
	    const src = anchors.getNode(name);

	    if (!src) {
	      const msg = `Aliased anchor not found: ${name}`;
	      errors.push(new PlainValueEc8e588e.YAMLReferenceError(node, msg));
	      return null;
	    } // Lazy resolution for circular references


	    const res = new Alias$1(src);

	    anchors._cstAliases.push(res);

	    return res;
	  }

	  const tagName = resolveTagName(doc, node);
	  if (tagName) return resolveTag(doc, node, tagName);

	  if (node.type !== PlainValueEc8e588e.Type.PLAIN) {
	    const msg = `Failed to resolve ${node.type} node here`;
	    errors.push(new PlainValueEc8e588e.YAMLSyntaxError(node, msg));
	    return null;
	  }

	  try {
	    const str = resolveString(doc, node);
	    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
	  } catch (error) {
	    if (!error.source) error.source = node;
	    errors.push(error);
	    return null;
	  }
	} // sets node.resolved on success


	function resolveNode(doc, node) {
	  if (!node) return null;
	  if (node.error) doc.errors.push(node.error);
	  const {
	    comments,
	    hasAnchor,
	    hasTag
	  } = resolveNodeProps(doc.errors, node);

	  if (hasAnchor) {
	    const {
	      anchors
	    } = doc;
	    const name = node.anchor;
	    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
	    // name have already been resolved, so it may safely be renamed.

	    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
	    // anchors need to be available during resolution to allow for
	    // circular references.

	    anchors.map[name] = node;
	  }

	  if (node.type === PlainValueEc8e588e.Type.ALIAS && (hasAnchor || hasTag)) {
	    const msg = 'An alias node must not specify any properties';
	    doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(node, msg));
	  }

	  const res = resolveNodeValue(doc, node);

	  if (res) {
	    res.range = [node.range.start, node.range.end];
	    if (doc.options.keepCstNodes) res.cstNode = node;
	    if (doc.options.keepNodeTypes) res.type = node.type;
	    const cb = comments.before.join('\n');

	    if (cb) {
	      res.commentBefore = res.commentBefore ? `${res.commentBefore}\n${cb}` : cb;
	    }

	    const ca = comments.after.join('\n');
	    if (ca) res.comment = res.comment ? `${res.comment}\n${ca}` : ca;
	  }

	  return node.resolved = res;
	}

	function resolveMap(doc, cst) {
	  if (cst.type !== PlainValueEc8e588e.Type.MAP && cst.type !== PlainValueEc8e588e.Type.FLOW_MAP) {
	    const msg = `A ${cst.type} node cannot be resolved as a mapping`;
	    doc.errors.push(new PlainValueEc8e588e.YAMLSyntaxError(cst, msg));
	    return null;
	  }

	  const {
	    comments,
	    items
	  } = cst.type === PlainValueEc8e588e.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
	  const map = new YAMLMap();
	  map.items = items;
	  resolveComments(map, comments);
	  let hasCollectionKey = false;

	  for (let i = 0; i < items.length; ++i) {
	    const {
	      key: iKey
	    } = items[i];
	    if (iKey instanceof Collection$1) hasCollectionKey = true;

	    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
	      items[i] = new Merge(items[i]);
	      const sources = items[i].value.items;
	      let error = null;
	      sources.some(node => {
	        if (node instanceof Alias$1) {
	          // During parsing, alias sources are CST nodes; to account for
	          // circular references their resolved values can't be used here.
	          const {
	            type
	          } = node.source;
	          if (type === PlainValueEc8e588e.Type.MAP || type === PlainValueEc8e588e.Type.FLOW_MAP) return false;
	          return error = 'Merge nodes aliases can only point to maps';
	        }

	        return error = 'Merge nodes can only have Alias nodes as values';
	      });
	      if (error) doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(cst, error));
	    } else {
	      for (let j = i + 1; j < items.length; ++j) {
	        const {
	          key: jKey
	        } = items[j];

	        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
	          const msg = `Map keys must be unique; "${iKey}" is repeated`;
	          doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(cst, msg));
	          break;
	        }
	      }
	    }
	  }

	  if (hasCollectionKey && !doc.options.mapAsMap) {
	    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
	    doc.warnings.push(new PlainValueEc8e588e.YAMLWarning(cst, warn));
	  }

	  cst.resolved = map;
	  return map;
	}

	const valueHasPairComment = ({
	  context: {
	    lineStart,
	    node,
	    src
	  },
	  props
	}) => {
	  if (props.length === 0) return false;
	  const {
	    start
	  } = props[0];
	  if (node && start > node.valueRange.start) return false;
	  if (src[start] !== PlainValueEc8e588e.Char.COMMENT) return false;

	  for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false;

	  return true;
	};

	function resolvePairComment(item, pair) {
	  if (!valueHasPairComment(item)) return;
	  const comment = item.getPropValue(0, PlainValueEc8e588e.Char.COMMENT, true);
	  let found = false;
	  const cb = pair.value.commentBefore;

	  if (cb && cb.startsWith(comment)) {
	    pair.value.commentBefore = cb.substr(comment.length + 1);
	    found = true;
	  } else {
	    const cc = pair.value.comment;

	    if (!item.node && cc && cc.startsWith(comment)) {
	      pair.value.comment = cc.substr(comment.length + 1);
	      found = true;
	    }
	  }

	  if (found) pair.comment = comment;
	}

	function resolveBlockMapItems(doc, cst) {
	  const comments = [];
	  const items = [];
	  let key = undefined;
	  let keyStart = null;

	  for (let i = 0; i < cst.items.length; ++i) {
	    const item = cst.items[i];

	    switch (item.type) {
	      case PlainValueEc8e588e.Type.BLANK_LINE:
	        comments.push({
	          afterKey: !!key,
	          before: items.length
	        });
	        break;

	      case PlainValueEc8e588e.Type.COMMENT:
	        comments.push({
	          afterKey: !!key,
	          before: items.length,
	          comment: item.comment
	        });
	        break;

	      case PlainValueEc8e588e.Type.MAP_KEY:
	        if (key !== undefined) items.push(new Pair(key));
	        if (item.error) doc.errors.push(item.error);
	        key = resolveNode(doc, item.node);
	        keyStart = null;
	        break;

	      case PlainValueEc8e588e.Type.MAP_VALUE:
	        {
	          if (key === undefined) key = null;
	          if (item.error) doc.errors.push(item.error);

	          if (!item.context.atLineStart && item.node && item.node.type === PlainValueEc8e588e.Type.MAP && !item.node.context.atLineStart) {
	            const msg = 'Nested mappings are not allowed in compact mappings';
	            doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(item.node, msg));
	          }

	          let valueNode = item.node;

	          if (!valueNode && item.props.length > 0) {
	            // Comments on an empty mapping value need to be preserved, so we
	            // need to construct a minimal empty node here to use instead of the
	            // missing `item.node`. -- eemeli/yaml#19
	            valueNode = new PlainValueEc8e588e.PlainValue(PlainValueEc8e588e.Type.PLAIN, []);
	            valueNode.context = {
	              parent: item,
	              src: item.context.src
	            };
	            const pos = item.range.start + 1;
	            valueNode.range = {
	              start: pos,
	              end: pos
	            };
	            valueNode.valueRange = {
	              start: pos,
	              end: pos
	            };

	            if (typeof item.range.origStart === 'number') {
	              const origPos = item.range.origStart + 1;
	              valueNode.range.origStart = valueNode.range.origEnd = origPos;
	              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
	            }
	          }

	          const pair = new Pair(key, resolveNode(doc, valueNode));
	          resolvePairComment(item, pair);
	          items.push(pair);

	          if (key && typeof keyStart === 'number') {
	            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
	          }

	          key = undefined;
	          keyStart = null;
	        }
	        break;

	      default:
	        if (key !== undefined) items.push(new Pair(key));
	        key = resolveNode(doc, item);
	        keyStart = item.range.start;
	        if (item.error) doc.errors.push(item.error);

	        next: for (let j = i + 1;; ++j) {
	          const nextItem = cst.items[j];

	          switch (nextItem && nextItem.type) {
	            case PlainValueEc8e588e.Type.BLANK_LINE:
	            case PlainValueEc8e588e.Type.COMMENT:
	              continue next;

	            case PlainValueEc8e588e.Type.MAP_VALUE:
	              break next;

	            default:
	              {
	                const msg = 'Implicit map keys need to be followed by map values';
	                doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(item, msg));
	                break next;
	              }
	          }
	        }

	        if (item.valueRangeContainsNewline) {
	          const msg = 'Implicit map keys need to be on a single line';
	          doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(item, msg));
	        }

	    }
	  }

	  if (key !== undefined) items.push(new Pair(key));
	  return {
	    comments,
	    items
	  };
	}

	function resolveFlowMapItems(doc, cst) {
	  const comments = [];
	  const items = [];
	  let key = undefined;
	  let explicitKey = false;
	  let next = '{';

	  for (let i = 0; i < cst.items.length; ++i) {
	    const item = cst.items[i];

	    if (typeof item.char === 'string') {
	      const {
	        char,
	        offset
	      } = item;

	      if (char === '?' && key === undefined && !explicitKey) {
	        explicitKey = true;
	        next = ':';
	        continue;
	      }

	      if (char === ':') {
	        if (key === undefined) key = null;

	        if (next === ':') {
	          next = ',';
	          continue;
	        }
	      } else {
	        if (explicitKey) {
	          if (key === undefined && char !== ',') key = null;
	          explicitKey = false;
	        }

	        if (key !== undefined) {
	          items.push(new Pair(key));
	          key = undefined;

	          if (char === ',') {
	            next = ':';
	            continue;
	          }
	        }
	      }

	      if (char === '}') {
	        if (i === cst.items.length - 1) continue;
	      } else if (char === next) {
	        next = ':';
	        continue;
	      }

	      const msg = `Flow map contains an unexpected ${char}`;
	      const err = new PlainValueEc8e588e.YAMLSyntaxError(cst, msg);
	      err.offset = offset;
	      doc.errors.push(err);
	    } else if (item.type === PlainValueEc8e588e.Type.BLANK_LINE) {
	      comments.push({
	        afterKey: !!key,
	        before: items.length
	      });
	    } else if (item.type === PlainValueEc8e588e.Type.COMMENT) {
	      checkFlowCommentSpace(doc.errors, item);
	      comments.push({
	        afterKey: !!key,
	        before: items.length,
	        comment: item.comment
	      });
	    } else if (key === undefined) {
	      if (next === ',') doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(item, 'Separator , missing in flow map'));
	      key = resolveNode(doc, item);
	    } else {
	      if (next !== ',') doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
	      items.push(new Pair(key, resolveNode(doc, item)));
	      key = undefined;
	      explicitKey = false;
	    }
	  }

	  checkFlowCollectionEnd(doc.errors, cst);
	  if (key !== undefined) items.push(new Pair(key));
	  return {
	    comments,
	    items
	  };
	}

	function resolveSeq(doc, cst) {
	  if (cst.type !== PlainValueEc8e588e.Type.SEQ && cst.type !== PlainValueEc8e588e.Type.FLOW_SEQ) {
	    const msg = `A ${cst.type} node cannot be resolved as a sequence`;
	    doc.errors.push(new PlainValueEc8e588e.YAMLSyntaxError(cst, msg));
	    return null;
	  }

	  const {
	    comments,
	    items
	  } = cst.type === PlainValueEc8e588e.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
	  const seq = new YAMLSeq();
	  seq.items = items;
	  resolveComments(seq, comments);

	  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection$1)) {
	    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
	    doc.warnings.push(new PlainValueEc8e588e.YAMLWarning(cst, warn));
	  }

	  cst.resolved = seq;
	  return seq;
	}

	function resolveBlockSeqItems(doc, cst) {
	  const comments = [];
	  const items = [];

	  for (let i = 0; i < cst.items.length; ++i) {
	    const item = cst.items[i];

	    switch (item.type) {
	      case PlainValueEc8e588e.Type.BLANK_LINE:
	        comments.push({
	          before: items.length
	        });
	        break;

	      case PlainValueEc8e588e.Type.COMMENT:
	        comments.push({
	          comment: item.comment,
	          before: items.length
	        });
	        break;

	      case PlainValueEc8e588e.Type.SEQ_ITEM:
	        if (item.error) doc.errors.push(item.error);
	        items.push(resolveNode(doc, item.node));

	        if (item.hasProps) {
	          const msg = 'Sequence items cannot have tags or anchors before the - indicator';
	          doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(item, msg));
	        }

	        break;

	      default:
	        if (item.error) doc.errors.push(item.error);
	        doc.errors.push(new PlainValueEc8e588e.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
	    }
	  }

	  return {
	    comments,
	    items
	  };
	}

	function resolveFlowSeqItems(doc, cst) {
	  const comments = [];
	  const items = [];
	  let explicitKey = false;
	  let key = undefined;
	  let keyStart = null;
	  let next = '[';
	  let prevItem = null;

	  for (let i = 0; i < cst.items.length; ++i) {
	    const item = cst.items[i];

	    if (typeof item.char === 'string') {
	      const {
	        char,
	        offset
	      } = item;

	      if (char !== ':' && (explicitKey || key !== undefined)) {
	        if (explicitKey && key === undefined) key = next ? items.pop() : null;
	        items.push(new Pair(key));
	        explicitKey = false;
	        key = undefined;
	        keyStart = null;
	      }

	      if (char === next) {
	        next = null;
	      } else if (!next && char === '?') {
	        explicitKey = true;
	      } else if (next !== '[' && char === ':' && key === undefined) {
	        if (next === ',') {
	          key = items.pop();

	          if (key instanceof Pair) {
	            const msg = 'Chaining flow sequence pairs is invalid';
	            const err = new PlainValueEc8e588e.YAMLSemanticError(cst, msg);
	            err.offset = offset;
	            doc.errors.push(err);
	          }

	          if (!explicitKey && typeof keyStart === 'number') {
	            const keyEnd = item.range ? item.range.start : item.offset;
	            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
	            const {
	              src
	            } = prevItem.context;

	            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\n') {
	              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';
	              doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(prevItem, msg));
	              break;
	            }
	          }
	        } else {
	          key = null;
	        }

	        keyStart = null;
	        explicitKey = false;
	        next = null;
	      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
	        const msg = `Flow sequence contains an unexpected ${char}`;
	        const err = new PlainValueEc8e588e.YAMLSyntaxError(cst, msg);
	        err.offset = offset;
	        doc.errors.push(err);
	      }
	    } else if (item.type === PlainValueEc8e588e.Type.BLANK_LINE) {
	      comments.push({
	        before: items.length
	      });
	    } else if (item.type === PlainValueEc8e588e.Type.COMMENT) {
	      checkFlowCommentSpace(doc.errors, item);
	      comments.push({
	        comment: item.comment,
	        before: items.length
	      });
	    } else {
	      if (next) {
	        const msg = `Expected a ${next} in flow sequence`;
	        doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(item, msg));
	      }

	      const value = resolveNode(doc, item);

	      if (key === undefined) {
	        items.push(value);
	        prevItem = item;
	      } else {
	        items.push(new Pair(key, value));
	        key = undefined;
	      }

	      keyStart = item.range.start;
	      next = ',';
	    }
	  }

	  checkFlowCollectionEnd(doc.errors, cst);
	  if (key !== undefined) items.push(new Pair(key));
	  return {
	    comments,
	    items
	  };
	}

	var Alias_1 = Alias$1;
	var Collection_1 = Collection$1;
	var Merge_1 = Merge;
	var Node_1$1 = Node$1;
	var Pair_1 = Pair;
	var Scalar_1 = Scalar;
	var YAMLMap_1 = YAMLMap;
	var YAMLSeq_1 = YAMLSeq;
	var addComment_1 = addComment;
	var binaryOptions_1 = binaryOptions;
	var boolOptions_1 = boolOptions;
	var findPair_1 = findPair;
	var intOptions_1 = intOptions;
	var isEmptyPath_1 = isEmptyPath;
	var nullOptions_1 = nullOptions;
	var resolveMap_1 = resolveMap;
	var resolveNode_1 = resolveNode;
	var resolveSeq_1 = resolveSeq;
	var resolveString_1 = resolveString;
	var strOptions_1 = strOptions;
	var stringifyNumber_1 = stringifyNumber;
	var stringifyString_1 = stringifyString;
	var toJSON_1 = toJSON;

	var resolveSeq4a68b39b = {
		Alias: Alias_1,
		Collection: Collection_1,
		Merge: Merge_1,
		Node: Node_1$1,
		Pair: Pair_1,
		Scalar: Scalar_1,
		YAMLMap: YAMLMap_1,
		YAMLSeq: YAMLSeq_1,
		addComment: addComment_1,
		binaryOptions: binaryOptions_1,
		boolOptions: boolOptions_1,
		findPair: findPair_1,
		intOptions: intOptions_1,
		isEmptyPath: isEmptyPath_1,
		nullOptions: nullOptions_1,
		resolveMap: resolveMap_1,
		resolveNode: resolveNode_1,
		resolveSeq: resolveSeq_1,
		resolveString: resolveString_1,
		strOptions: strOptions_1,
		stringifyNumber: stringifyNumber_1,
		stringifyString: stringifyString_1,
		toJSON: toJSON_1
	};

	/* global atob, btoa, Buffer */
	const binary = {
	  identify: value => value instanceof Uint8Array,
	  // Buffer inherits from Uint8Array
	  default: false,
	  tag: 'tag:yaml.org,2002:binary',

	  /**
	   * Returns a Buffer in node and an Uint8Array in browsers
	   *
	   * To use the resulting buffer as an image, you'll want to do something like:
	   *
	   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
	   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
	   */
	  resolve: (doc, node) => {
	    const src = resolveSeq4a68b39b.resolveString(doc, node);

	    if (typeof Buffer === 'function') {
	      return Buffer.from(src, 'base64');
	    } else if (typeof atob === 'function') {
	      // On IE 11, atob() can't handle newlines
	      const str = atob(src.replace(/[\n\r]/g, ''));
	      const buffer = new Uint8Array(str.length);

	      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);

	      return buffer;
	    } else {
	      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
	      doc.errors.push(new PlainValueEc8e588e.YAMLReferenceError(node, msg));
	      return null;
	    }
	  },
	  options: resolveSeq4a68b39b.binaryOptions,
	  stringify: ({
	    comment,
	    type,
	    value
	  }, ctx, onComment, onChompKeep) => {
	    let src;

	    if (typeof Buffer === 'function') {
	      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
	    } else if (typeof btoa === 'function') {
	      let s = '';

	      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);

	      src = btoa(s);
	    } else {
	      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
	    }

	    if (!type) type = resolveSeq4a68b39b.binaryOptions.defaultType;

	    if (type === PlainValueEc8e588e.Type.QUOTE_DOUBLE) {
	      value = src;
	    } else {
	      const {
	        lineWidth
	      } = resolveSeq4a68b39b.binaryOptions;
	      const n = Math.ceil(src.length / lineWidth);
	      const lines = new Array(n);

	      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
	        lines[i] = src.substr(o, lineWidth);
	      }

	      value = lines.join(type === PlainValueEc8e588e.Type.BLOCK_LITERAL ? '\n' : ' ');
	    }

	    return resolveSeq4a68b39b.stringifyString({
	      comment,
	      type,
	      value
	    }, ctx, onComment, onChompKeep);
	  }
	};

	function parsePairs(doc, cst) {
	  const seq = resolveSeq4a68b39b.resolveSeq(doc, cst);

	  for (let i = 0; i < seq.items.length; ++i) {
	    let item = seq.items[i];
	    if (item instanceof resolveSeq4a68b39b.Pair) continue;else if (item instanceof resolveSeq4a68b39b.YAMLMap) {
	      if (item.items.length > 1) {
	        const msg = 'Each pair must have its own sequence indicator';
	        throw new PlainValueEc8e588e.YAMLSemanticError(cst, msg);
	      }

	      const pair = item.items[0] || new resolveSeq4a68b39b.Pair();
	      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\n${pair.commentBefore}` : item.commentBefore;
	      if (item.comment) pair.comment = pair.comment ? `${item.comment}\n${pair.comment}` : item.comment;
	      item = pair;
	    }
	    seq.items[i] = item instanceof resolveSeq4a68b39b.Pair ? item : new resolveSeq4a68b39b.Pair(item);
	  }

	  return seq;
	}
	function createPairs(schema, iterable, ctx) {
	  const pairs = new resolveSeq4a68b39b.YAMLSeq(schema);
	  pairs.tag = 'tag:yaml.org,2002:pairs';

	  for (const it of iterable) {
	    let key, value;

	    if (Array.isArray(it)) {
	      if (it.length === 2) {
	        key = it[0];
	        value = it[1];
	      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
	    } else if (it && it instanceof Object) {
	      const keys = Object.keys(it);

	      if (keys.length === 1) {
	        key = keys[0];
	        value = it[key];
	      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
	    } else {
	      key = it;
	    }

	    const pair = schema.createPair(key, value, ctx);
	    pairs.items.push(pair);
	  }

	  return pairs;
	}
	const pairs = {
	  default: false,
	  tag: 'tag:yaml.org,2002:pairs',
	  resolve: parsePairs,
	  createNode: createPairs
	};

	class YAMLOMap extends resolveSeq4a68b39b.YAMLSeq {
	  constructor() {
	    super();

	    PlainValueEc8e588e._defineProperty(this, "add", resolveSeq4a68b39b.YAMLMap.prototype.add.bind(this));

	    PlainValueEc8e588e._defineProperty(this, "delete", resolveSeq4a68b39b.YAMLMap.prototype.delete.bind(this));

	    PlainValueEc8e588e._defineProperty(this, "get", resolveSeq4a68b39b.YAMLMap.prototype.get.bind(this));

	    PlainValueEc8e588e._defineProperty(this, "has", resolveSeq4a68b39b.YAMLMap.prototype.has.bind(this));

	    PlainValueEc8e588e._defineProperty(this, "set", resolveSeq4a68b39b.YAMLMap.prototype.set.bind(this));

	    this.tag = YAMLOMap.tag;
	  }

	  toJSON(_, ctx) {
	    const map = new Map();
	    if (ctx && ctx.onCreate) ctx.onCreate(map);

	    for (const pair of this.items) {
	      let key, value;

	      if (pair instanceof resolveSeq4a68b39b.Pair) {
	        key = resolveSeq4a68b39b.toJSON(pair.key, '', ctx);
	        value = resolveSeq4a68b39b.toJSON(pair.value, key, ctx);
	      } else {
	        key = resolveSeq4a68b39b.toJSON(pair, '', ctx);
	      }

	      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
	      map.set(key, value);
	    }

	    return map;
	  }

	}

	PlainValueEc8e588e._defineProperty(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

	function parseOMap(doc, cst) {
	  const pairs = parsePairs(doc, cst);
	  const seenKeys = [];

	  for (const {
	    key
	  } of pairs.items) {
	    if (key instanceof resolveSeq4a68b39b.Scalar) {
	      if (seenKeys.includes(key.value)) {
	        const msg = 'Ordered maps must not include duplicate keys';
	        throw new PlainValueEc8e588e.YAMLSemanticError(cst, msg);
	      } else {
	        seenKeys.push(key.value);
	      }
	    }
	  }

	  return Object.assign(new YAMLOMap(), pairs);
	}

	function createOMap(schema, iterable, ctx) {
	  const pairs = createPairs(schema, iterable, ctx);
	  const omap = new YAMLOMap();
	  omap.items = pairs.items;
	  return omap;
	}

	const omap = {
	  identify: value => value instanceof Map,
	  nodeClass: YAMLOMap,
	  default: false,
	  tag: 'tag:yaml.org,2002:omap',
	  resolve: parseOMap,
	  createNode: createOMap
	};

	class YAMLSet extends resolveSeq4a68b39b.YAMLMap {
	  constructor() {
	    super();
	    this.tag = YAMLSet.tag;
	  }

	  add(key) {
	    const pair = key instanceof resolveSeq4a68b39b.Pair ? key : new resolveSeq4a68b39b.Pair(key);
	    const prev = resolveSeq4a68b39b.findPair(this.items, pair.key);
	    if (!prev) this.items.push(pair);
	  }

	  get(key, keepPair) {
	    const pair = resolveSeq4a68b39b.findPair(this.items, key);
	    return !keepPair && pair instanceof resolveSeq4a68b39b.Pair ? pair.key instanceof resolveSeq4a68b39b.Scalar ? pair.key.value : pair.key : pair;
	  }

	  set(key, value) {
	    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
	    const prev = resolveSeq4a68b39b.findPair(this.items, key);

	    if (prev && !value) {
	      this.items.splice(this.items.indexOf(prev), 1);
	    } else if (!prev && value) {
	      this.items.push(new resolveSeq4a68b39b.Pair(key));
	    }
	  }

	  toJSON(_, ctx) {
	    return super.toJSON(_, ctx, Set);
	  }

	  toString(ctx, onComment, onChompKeep) {
	    if (!ctx) return JSON.stringify(this);
	    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
	  }

	}

	PlainValueEc8e588e._defineProperty(YAMLSet, "tag", 'tag:yaml.org,2002:set');

	function parseSet(doc, cst) {
	  const map = resolveSeq4a68b39b.resolveMap(doc, cst);
	  if (!map.hasAllNullValues()) throw new PlainValueEc8e588e.YAMLSemanticError(cst, 'Set items must all have null values');
	  return Object.assign(new YAMLSet(), map);
	}

	function createSet(schema, iterable, ctx) {
	  const set = new YAMLSet();

	  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));

	  return set;
	}

	const set = {
	  identify: value => value instanceof Set,
	  nodeClass: YAMLSet,
	  default: false,
	  tag: 'tag:yaml.org,2002:set',
	  resolve: parseSet,
	  createNode: createSet
	};

	const parseSexagesimal = (sign, parts) => {
	  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);
	  return sign === '-' ? -n : n;
	}; // hhhh:mm:ss.sss


	const stringifySexagesimal = ({
	  value
	}) => {
	  if (isNaN(value) || !isFinite(value)) return resolveSeq4a68b39b.stringifyNumber(value);
	  let sign = '';

	  if (value < 0) {
	    sign = '-';
	    value = Math.abs(value);
	  }

	  const parts = [value % 60]; // seconds, including ms

	  if (value < 60) {
	    parts.unshift(0); // at least one : is required
	  } else {
	    value = Math.round((value - parts[0]) / 60);
	    parts.unshift(value % 60); // minutes

	    if (value >= 60) {
	      value = Math.round((value - parts[0]) / 60);
	      parts.unshift(value); // hours
	    }
	  }

	  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
	  ;
	};

	const intTime = {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'TIME',
	  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
	  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
	  stringify: stringifySexagesimal
	};
	const floatTime = {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'TIME',
	  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
	  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
	  stringify: stringifySexagesimal
	};
	const timestamp = {
	  identify: value => value instanceof Date,
	  default: true,
	  tag: 'tag:yaml.org,2002:timestamp',
	  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
	  // may be omitted altogether, resulting in a date format. In such a case, the time part is
	  // assumed to be 00:00:00Z (start of day, UTC).
	  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
	  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
	  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
	  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
	  ')?' + ')$'),
	  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
	    if (millisec) millisec = (millisec + '00').substr(1, 3);
	    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

	    if (tz && tz !== 'Z') {
	      let d = parseSexagesimal(tz[0], tz.slice(1));
	      if (Math.abs(d) < 30) d *= 60;
	      date -= 60000 * d;
	    }

	    return new Date(date);
	  },
	  stringify: ({
	    value
	  }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
	};

	/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */
	function shouldWarn(deprecation) {
	  const env = typeof process !== 'undefined' && process.env || {};

	  if (deprecation) {
	    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
	    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
	  }

	  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
	  return !env.YAML_SILENCE_WARNINGS;
	}

	function warn(warning, type) {
	  if (shouldWarn(false)) {
	    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
	    // https://github.com/facebook/jest/issues/2549

	    if (emit) emit(warning, type);else {
	      // eslint-disable-next-line no-console
	      console.warn(type ? `${type}: ${warning}` : warning);
	    }
	  }
	}
	function warnFileDeprecation(filename) {
	  if (shouldWarn(true)) {
	    const path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
	    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');
	  }
	}
	const warned = {};
	function warnOptionDeprecation(name, alternative) {
	  if (!warned[name] && shouldWarn(true)) {
	    warned[name] = true;
	    let msg = `The option '${name}' will be removed in a future release`;
	    msg += alternative ? `, use '${alternative}' instead.` : '.';
	    warn(msg, 'DeprecationWarning');
	  }
	}

	var binary_1 = binary;
	var floatTime_1 = floatTime;
	var intTime_1 = intTime;
	var omap_1 = omap;
	var pairs_1 = pairs;
	var set_1 = set;
	var timestamp_1 = timestamp;
	var warn_1 = warn;
	var warnFileDeprecation_1 = warnFileDeprecation;
	var warnOptionDeprecation_1 = warnOptionDeprecation;

	var warnings39684f17 = {
		binary: binary_1,
		floatTime: floatTime_1,
		intTime: intTime_1,
		omap: omap_1,
		pairs: pairs_1,
		set: set_1,
		timestamp: timestamp_1,
		warn: warn_1,
		warnFileDeprecation: warnFileDeprecation_1,
		warnOptionDeprecation: warnOptionDeprecation_1
	};

	function createMap(schema, obj, ctx) {
	  const map = new resolveSeq4a68b39b.YAMLMap(schema);

	  if (obj instanceof Map) {
	    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));
	  } else if (obj && typeof obj === 'object') {
	    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));
	  }

	  if (typeof schema.sortMapEntries === 'function') {
	    map.items.sort(schema.sortMapEntries);
	  }

	  return map;
	}

	const map = {
	  createNode: createMap,
	  default: true,
	  nodeClass: resolveSeq4a68b39b.YAMLMap,
	  tag: 'tag:yaml.org,2002:map',
	  resolve: resolveSeq4a68b39b.resolveMap
	};

	function createSeq(schema, obj, ctx) {
	  const seq = new resolveSeq4a68b39b.YAMLSeq(schema);

	  if (obj && obj[Symbol.iterator]) {
	    for (const it of obj) {
	      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
	      seq.items.push(v);
	    }
	  }

	  return seq;
	}

	const seq = {
	  createNode: createSeq,
	  default: true,
	  nodeClass: resolveSeq4a68b39b.YAMLSeq,
	  tag: 'tag:yaml.org,2002:seq',
	  resolve: resolveSeq4a68b39b.resolveSeq
	};

	const string = {
	  identify: value => typeof value === 'string',
	  default: true,
	  tag: 'tag:yaml.org,2002:str',
	  resolve: resolveSeq4a68b39b.resolveString,

	  stringify(item, ctx, onComment, onChompKeep) {
	    ctx = Object.assign({
	      actualString: true
	    }, ctx);
	    return resolveSeq4a68b39b.stringifyString(item, ctx, onComment, onChompKeep);
	  },

	  options: resolveSeq4a68b39b.strOptions
	};

	const failsafe = [map, seq, string];

	/* global BigInt */

	const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);

	const intResolve = (src, part, radix) => resolveSeq4a68b39b.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);

	function intStringify(node, radix, prefix) {
	  const {
	    value
	  } = node;
	  if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
	  return resolveSeq4a68b39b.stringifyNumber(node);
	}

	const nullObj = {
	  identify: value => value == null,
	  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq4a68b39b.Scalar(null) : null,
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^(?:~|[Nn]ull|NULL)?$/,
	  resolve: () => null,
	  options: resolveSeq4a68b39b.nullOptions,
	  stringify: () => resolveSeq4a68b39b.nullOptions.nullStr
	};
	const boolObj = {
	  identify: value => typeof value === 'boolean',
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
	  resolve: str => str[0] === 't' || str[0] === 'T',
	  options: resolveSeq4a68b39b.boolOptions,
	  stringify: ({
	    value
	  }) => value ? resolveSeq4a68b39b.boolOptions.trueStr : resolveSeq4a68b39b.boolOptions.falseStr
	};
	const octObj = {
	  identify: value => intIdentify(value) && value >= 0,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'OCT',
	  test: /^0o([0-7]+)$/,
	  resolve: (str, oct) => intResolve(str, oct, 8),
	  options: resolveSeq4a68b39b.intOptions,
	  stringify: node => intStringify(node, 8, '0o')
	};
	const intObj = {
	  identify: intIdentify,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^[-+]?[0-9]+$/,
	  resolve: str => intResolve(str, str, 10),
	  options: resolveSeq4a68b39b.intOptions,
	  stringify: resolveSeq4a68b39b.stringifyNumber
	};
	const hexObj = {
	  identify: value => intIdentify(value) && value >= 0,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'HEX',
	  test: /^0x([0-9a-fA-F]+)$/,
	  resolve: (str, hex) => intResolve(str, hex, 16),
	  options: resolveSeq4a68b39b.intOptions,
	  stringify: node => intStringify(node, 16, '0x')
	};
	const nanObj = {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^(?:[-+]?\.inf|(\.nan))$/i,
	  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
	  stringify: resolveSeq4a68b39b.stringifyNumber
	};
	const expObj = {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'EXP',
	  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
	  resolve: str => parseFloat(str),
	  stringify: ({
	    value
	  }) => Number(value).toExponential()
	};
	const floatObj = {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,

	  resolve(str, frac1, frac2) {
	    const frac = frac1 || frac2;
	    const node = new resolveSeq4a68b39b.Scalar(parseFloat(str));
	    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
	    return node;
	  },

	  stringify: resolveSeq4a68b39b.stringifyNumber
	};
	const core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);

	/* global BigInt */

	const intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);

	const stringifyJSON = ({
	  value
	}) => JSON.stringify(value);

	const json = [map, seq, {
	  identify: value => typeof value === 'string',
	  default: true,
	  tag: 'tag:yaml.org,2002:str',
	  resolve: resolveSeq4a68b39b.resolveString,
	  stringify: stringifyJSON
	}, {
	  identify: value => value == null,
	  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq4a68b39b.Scalar(null) : null,
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^null$/,
	  resolve: () => null,
	  stringify: stringifyJSON
	}, {
	  identify: value => typeof value === 'boolean',
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^true|false$/,
	  resolve: str => str === 'true',
	  stringify: stringifyJSON
	}, {
	  identify: intIdentify$1,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^-?(?:0|[1-9][0-9]*)$/,
	  resolve: str => resolveSeq4a68b39b.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
	  stringify: ({
	    value
	  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
	}, {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
	  resolve: str => parseFloat(str),
	  stringify: stringifyJSON
	}];

	json.scalarFallback = str => {
	  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
	};

	/* global BigInt */

	const boolStringify = ({
	  value
	}) => value ? resolveSeq4a68b39b.boolOptions.trueStr : resolveSeq4a68b39b.boolOptions.falseStr;

	const intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);

	function intResolve$1(sign, src, radix) {
	  let str = src.replace(/_/g, '');

	  if (resolveSeq4a68b39b.intOptions.asBigInt) {
	    switch (radix) {
	      case 2:
	        str = `0b${str}`;
	        break;

	      case 8:
	        str = `0o${str}`;
	        break;

	      case 16:
	        str = `0x${str}`;
	        break;
	    }

	    const n = BigInt(str);
	    return sign === '-' ? BigInt(-1) * n : n;
	  }

	  const n = parseInt(str, radix);
	  return sign === '-' ? -1 * n : n;
	}

	function intStringify$1(node, radix, prefix) {
	  const {
	    value
	  } = node;

	  if (intIdentify$2(value)) {
	    const str = value.toString(radix);
	    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
	  }

	  return resolveSeq4a68b39b.stringifyNumber(node);
	}

	const yaml11 = failsafe.concat([{
	  identify: value => value == null,
	  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq4a68b39b.Scalar(null) : null,
	  default: true,
	  tag: 'tag:yaml.org,2002:null',
	  test: /^(?:~|[Nn]ull|NULL)?$/,
	  resolve: () => null,
	  options: resolveSeq4a68b39b.nullOptions,
	  stringify: () => resolveSeq4a68b39b.nullOptions.nullStr
	}, {
	  identify: value => typeof value === 'boolean',
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
	  resolve: () => true,
	  options: resolveSeq4a68b39b.boolOptions,
	  stringify: boolStringify
	}, {
	  identify: value => typeof value === 'boolean',
	  default: true,
	  tag: 'tag:yaml.org,2002:bool',
	  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
	  resolve: () => false,
	  options: resolveSeq4a68b39b.boolOptions,
	  stringify: boolStringify
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'BIN',
	  test: /^([-+]?)0b([0-1_]+)$/,
	  resolve: (str, sign, bin) => intResolve$1(sign, bin, 2),
	  stringify: node => intStringify$1(node, 2, '0b')
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'OCT',
	  test: /^([-+]?)0([0-7_]+)$/,
	  resolve: (str, sign, oct) => intResolve$1(sign, oct, 8),
	  stringify: node => intStringify$1(node, 8, '0')
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  test: /^([-+]?)([0-9][0-9_]*)$/,
	  resolve: (str, sign, abs) => intResolve$1(sign, abs, 10),
	  stringify: resolveSeq4a68b39b.stringifyNumber
	}, {
	  identify: intIdentify$2,
	  default: true,
	  tag: 'tag:yaml.org,2002:int',
	  format: 'HEX',
	  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
	  resolve: (str, sign, hex) => intResolve$1(sign, hex, 16),
	  stringify: node => intStringify$1(node, 16, '0x')
	}, {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^(?:[-+]?\.inf|(\.nan))$/i,
	  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
	  stringify: resolveSeq4a68b39b.stringifyNumber
	}, {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  format: 'EXP',
	  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
	  resolve: str => parseFloat(str.replace(/_/g, '')),
	  stringify: ({
	    value
	  }) => Number(value).toExponential()
	}, {
	  identify: value => typeof value === 'number',
	  default: true,
	  tag: 'tag:yaml.org,2002:float',
	  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,

	  resolve(str, frac) {
	    const node = new resolveSeq4a68b39b.Scalar(parseFloat(str.replace(/_/g, '')));

	    if (frac) {
	      const f = frac.replace(/_/g, '');
	      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
	    }

	    return node;
	  },

	  stringify: resolveSeq4a68b39b.stringifyNumber
	}], warnings39684f17.binary, warnings39684f17.omap, warnings39684f17.pairs, warnings39684f17.set, warnings39684f17.intTime, warnings39684f17.floatTime, warnings39684f17.timestamp);

	const schemas = {
	  core,
	  failsafe,
	  json,
	  yaml11
	};
	const tags = {
	  binary: warnings39684f17.binary,
	  bool: boolObj,
	  float: floatObj,
	  floatExp: expObj,
	  floatNaN: nanObj,
	  floatTime: warnings39684f17.floatTime,
	  int: intObj,
	  intHex: hexObj,
	  intOct: octObj,
	  intTime: warnings39684f17.intTime,
	  map,
	  null: nullObj,
	  omap: warnings39684f17.omap,
	  pairs: warnings39684f17.pairs,
	  seq,
	  set: warnings39684f17.set,
	  timestamp: warnings39684f17.timestamp
	};

	function findTagObject(value, tagName, tags) {
	  if (tagName) {
	    const match = tags.filter(t => t.tag === tagName);
	    const tagObj = match.find(t => !t.format) || match[0];
	    if (!tagObj) throw new Error(`Tag ${tagName} not found`);
	    return tagObj;
	  } // TODO: deprecate/remove class check


	  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
	}

	function createNode(value, tagName, ctx) {
	  if (value instanceof resolveSeq4a68b39b.Node) return value;
	  const {
	    defaultPrefix,
	    onTagObj,
	    prevObjects,
	    schema,
	    wrapScalars
	  } = ctx;
	  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);
	  let tagObj = findTagObject(value, tagName, schema.tags);

	  if (!tagObj) {
	    if (typeof value.toJSON === 'function') value = value.toJSON();
	    if (typeof value !== 'object') return wrapScalars ? new resolveSeq4a68b39b.Scalar(value) : value;
	    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
	  }

	  if (onTagObj) {
	    onTagObj(tagObj);
	    delete ctx.onTagObj;
	  } // Detect duplicate references to the same object & use Alias nodes for all
	  // after first. The `obj` wrapper allows for circular references to resolve.


	  const obj = {};

	  if (value && typeof value === 'object' && prevObjects) {
	    const prev = prevObjects.get(value);

	    if (prev) {
	      const alias = new resolveSeq4a68b39b.Alias(prev); // leaves source dirty; must be cleaned by caller

	      ctx.aliasNodes.push(alias); // defined along with prevObjects

	      return alias;
	    }

	    obj.value = value;
	    prevObjects.set(value, obj);
	  }

	  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq4a68b39b.Scalar(value) : value;
	  if (tagName && obj.node instanceof resolveSeq4a68b39b.Node) obj.node.tag = tagName;
	  return obj.node;
	}

	function getSchemaTags(schemas, knownTags, customTags, schemaId) {
	  let tags = schemas[schemaId.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'

	  if (!tags) {
	    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');
	    throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
	  }

	  if (Array.isArray(customTags)) {
	    for (const tag of customTags) tags = tags.concat(tag);
	  } else if (typeof customTags === 'function') {
	    tags = customTags(tags.slice());
	  }

	  for (let i = 0; i < tags.length; ++i) {
	    const tag = tags[i];

	    if (typeof tag === 'string') {
	      const tagObj = knownTags[tag];

	      if (!tagObj) {
	        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');
	        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
	      }

	      tags[i] = tagObj;
	    }
	  }

	  return tags;
	}

	const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

	class Schema {
	  // TODO: remove in v2
	  // TODO: remove in v2
	  constructor({
	    customTags,
	    merge,
	    schema,
	    sortMapEntries,
	    tags: deprecatedCustomTags
	  }) {
	    this.merge = !!merge;
	    this.name = schema;
	    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
	    if (!customTags && deprecatedCustomTags) warnings39684f17.warnOptionDeprecation('tags', 'customTags');
	    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
	  }

	  createNode(value, wrapScalars, tagName, ctx) {
	    const baseCtx = {
	      defaultPrefix: Schema.defaultPrefix,
	      schema: this,
	      wrapScalars
	    };
	    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
	    return createNode(value, tagName, createCtx);
	  }

	  createPair(key, value, ctx) {
	    if (!ctx) ctx = {
	      wrapScalars: true
	    };
	    const k = this.createNode(key, ctx.wrapScalars, null, ctx);
	    const v = this.createNode(value, ctx.wrapScalars, null, ctx);
	    return new resolveSeq4a68b39b.Pair(k, v);
	  }

	}

	PlainValueEc8e588e._defineProperty(Schema, "defaultPrefix", PlainValueEc8e588e.defaultTagPrefix);

	PlainValueEc8e588e._defineProperty(Schema, "defaultTags", PlainValueEc8e588e.defaultTags);

	var Schema_1 = Schema;

	var Schema42e9705c = {
		Schema: Schema_1
	};

	const defaultOptions = {
	  anchorPrefix: 'a',
	  customTags: null,
	  indent: 2,
	  indentSeq: true,
	  keepCstNodes: false,
	  keepNodeTypes: true,
	  keepBlobsInJSON: true,
	  mapAsMap: false,
	  maxAliasCount: 100,
	  prettyErrors: false,
	  // TODO Set true in v2
	  simpleKeys: false,
	  version: '1.2'
	};
	const scalarOptions = {
	  get binary() {
	    return resolveSeq4a68b39b.binaryOptions;
	  },

	  set binary(opt) {
	    Object.assign(resolveSeq4a68b39b.binaryOptions, opt);
	  },

	  get bool() {
	    return resolveSeq4a68b39b.boolOptions;
	  },

	  set bool(opt) {
	    Object.assign(resolveSeq4a68b39b.boolOptions, opt);
	  },

	  get int() {
	    return resolveSeq4a68b39b.intOptions;
	  },

	  set int(opt) {
	    Object.assign(resolveSeq4a68b39b.intOptions, opt);
	  },

	  get null() {
	    return resolveSeq4a68b39b.nullOptions;
	  },

	  set null(opt) {
	    Object.assign(resolveSeq4a68b39b.nullOptions, opt);
	  },

	  get str() {
	    return resolveSeq4a68b39b.strOptions;
	  },

	  set str(opt) {
	    Object.assign(resolveSeq4a68b39b.strOptions, opt);
	  }

	};
	const documentOptions = {
	  '1.0': {
	    schema: 'yaml-1.1',
	    merge: true,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: PlainValueEc8e588e.defaultTagPrefix
	    }, {
	      handle: '!!',
	      prefix: 'tag:private.yaml.org,2002:'
	    }]
	  },
	  '1.1': {
	    schema: 'yaml-1.1',
	    merge: true,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: '!'
	    }, {
	      handle: '!!',
	      prefix: PlainValueEc8e588e.defaultTagPrefix
	    }]
	  },
	  '1.2': {
	    schema: 'core',
	    merge: false,
	    tagPrefixes: [{
	      handle: '!',
	      prefix: '!'
	    }, {
	      handle: '!!',
	      prefix: PlainValueEc8e588e.defaultTagPrefix
	    }]
	  }
	};

	function stringifyTag(doc, tag) {
	  if ((doc.version || doc.options.version) === '1.0') {
	    const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
	    if (priv) return '!' + priv[1];
	    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
	    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;
	  }

	  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);

	  if (!p) {
	    const dtp = doc.getDefaults().tagPrefixes;
	    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);
	  }

	  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;
	  const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, ch => ({
	    '!': '%21',
	    ',': '%2C',
	    '[': '%5B',
	    ']': '%5D',
	    '{': '%7B',
	    '}': '%7D'
	  })[ch]);
	  return p.handle + suffix;
	}

	function getTagObject(tags, item) {
	  if (item instanceof resolveSeq4a68b39b.Alias) return resolveSeq4a68b39b.Alias;

	  if (item.tag) {
	    const match = tags.filter(t => t.tag === item.tag);
	    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];
	  }

	  let tagObj, obj;

	  if (item instanceof resolveSeq4a68b39b.Scalar) {
	    obj = item.value; // TODO: deprecate/remove class check

	    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
	    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);
	  } else {
	    obj = item;
	    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
	  }

	  if (!tagObj) {
	    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
	    throw new Error(`Tag not resolved for ${name} value`);
	  }

	  return tagObj;
	} // needs to be called before value stringifier to allow for circular anchor refs


	function stringifyProps(node, tagObj, {
	  anchors,
	  doc
	}) {
	  const props = [];
	  const anchor = doc.anchors.getName(node);

	  if (anchor) {
	    anchors[anchor] = node;
	    props.push(`&${anchor}`);
	  }

	  if (node.tag) {
	    props.push(stringifyTag(doc, node.tag));
	  } else if (!tagObj.default) {
	    props.push(stringifyTag(doc, tagObj.tag));
	  }

	  return props.join(' ');
	}

	function stringify(item, ctx, onComment, onChompKeep) {
	  const {
	    anchors,
	    schema
	  } = ctx.doc;
	  let tagObj;

	  if (!(item instanceof resolveSeq4a68b39b.Node)) {
	    const createCtx = {
	      aliasNodes: [],
	      onTagObj: o => tagObj = o,
	      prevObjects: new Map()
	    };
	    item = schema.createNode(item, true, null, createCtx);

	    for (const alias of createCtx.aliasNodes) {
	      alias.source = alias.source.node;
	      let name = anchors.getName(alias.source);

	      if (!name) {
	        name = anchors.newName();
	        anchors.map[name] = alias.source;
	      }
	    }
	  }

	  if (item instanceof resolveSeq4a68b39b.Pair) return item.toString(ctx, onComment, onChompKeep);
	  if (!tagObj) tagObj = getTagObject(schema.tags, item);
	  const props = stringifyProps(item, tagObj, ctx);
	  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
	  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq4a68b39b.Scalar ? resolveSeq4a68b39b.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
	  if (!props) return str;
	  return item instanceof resolveSeq4a68b39b.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
	}

	class Anchors {
	  static validAnchorNode(node) {
	    return node instanceof resolveSeq4a68b39b.Scalar || node instanceof resolveSeq4a68b39b.YAMLSeq || node instanceof resolveSeq4a68b39b.YAMLMap;
	  }

	  constructor(prefix) {
	    PlainValueEc8e588e._defineProperty(this, "map", {});

	    this.prefix = prefix;
	  }

	  createAlias(node, name) {
	    this.setAnchor(node, name);
	    return new resolveSeq4a68b39b.Alias(node);
	  }

	  createMergePair(...sources) {
	    const merge = new resolveSeq4a68b39b.Merge();
	    merge.value.items = sources.map(s => {
	      if (s instanceof resolveSeq4a68b39b.Alias) {
	        if (s.source instanceof resolveSeq4a68b39b.YAMLMap) return s;
	      } else if (s instanceof resolveSeq4a68b39b.YAMLMap) {
	        return this.createAlias(s);
	      }

	      throw new Error('Merge sources must be Map nodes or their Aliases');
	    });
	    return merge;
	  }

	  getName(node) {
	    const {
	      map
	    } = this;
	    return Object.keys(map).find(a => map[a] === node);
	  }

	  getNames() {
	    return Object.keys(this.map);
	  }

	  getNode(name) {
	    return this.map[name];
	  }

	  newName(prefix) {
	    if (!prefix) prefix = this.prefix;
	    const names = Object.keys(this.map);

	    for (let i = 1; true; ++i) {
	      const name = `${prefix}${i}`;
	      if (!names.includes(name)) return name;
	    }
	  } // During parsing, map & aliases contain CST nodes


	  resolveNodes() {
	    const {
	      map,
	      _cstAliases
	    } = this;
	    Object.keys(map).forEach(a => {
	      map[a] = map[a].resolved;
	    });

	    _cstAliases.forEach(a => {
	      a.source = a.source.resolved;
	    });

	    delete this._cstAliases;
	  }

	  setAnchor(node, name) {
	    if (node != null && !Anchors.validAnchorNode(node)) {
	      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
	    }

	    if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
	      throw new Error('Anchor names must not contain whitespace or control characters');
	    }

	    const {
	      map
	    } = this;
	    const prev = node && Object.keys(map).find(a => map[a] === node);

	    if (prev) {
	      if (!name) {
	        return prev;
	      } else if (prev !== name) {
	        delete map[prev];
	        map[name] = node;
	      }
	    } else {
	      if (!name) {
	        if (!node) return null;
	        name = this.newName();
	      }

	      map[name] = node;
	    }

	    return name;
	  }

	}

	const visit = (node, tags) => {
	  if (node && typeof node === 'object') {
	    const {
	      tag
	    } = node;

	    if (node instanceof resolveSeq4a68b39b.Collection) {
	      if (tag) tags[tag] = true;
	      node.items.forEach(n => visit(n, tags));
	    } else if (node instanceof resolveSeq4a68b39b.Pair) {
	      visit(node.key, tags);
	      visit(node.value, tags);
	    } else if (node instanceof resolveSeq4a68b39b.Scalar) {
	      if (tag) tags[tag] = true;
	    }
	  }

	  return tags;
	};

	const listTagNames = node => Object.keys(visit(node, {}));

	function parseContents(doc, contents) {
	  const comments = {
	    before: [],
	    after: []
	  };
	  let body = undefined;
	  let spaceBefore = false;

	  for (const node of contents) {
	    if (node.valueRange) {
	      if (body !== undefined) {
	        const msg = 'Document contains trailing content not separated by a ... or --- line';
	        doc.errors.push(new PlainValueEc8e588e.YAMLSyntaxError(node, msg));
	        break;
	      }

	      const res = resolveSeq4a68b39b.resolveNode(doc, node);

	      if (spaceBefore) {
	        res.spaceBefore = true;
	        spaceBefore = false;
	      }

	      body = res;
	    } else if (node.comment !== null) {
	      const cc = body === undefined ? comments.before : comments.after;
	      cc.push(node.comment);
	    } else if (node.type === PlainValueEc8e588e.Type.BLANK_LINE) {
	      spaceBefore = true;

	      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {
	        // space-separated comments at start are parsed as document comments
	        doc.commentBefore = comments.before.join('\n');
	        comments.before = [];
	      }
	    }
	  }

	  doc.contents = body || null;

	  if (!body) {
	    doc.comment = comments.before.concat(comments.after).join('\n') || null;
	  } else {
	    const cb = comments.before.join('\n');

	    if (cb) {
	      const cbNode = body instanceof resolveSeq4a68b39b.Collection && body.items[0] ? body.items[0] : body;
	      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\n${cbNode.commentBefore}` : cb;
	    }

	    doc.comment = comments.after.join('\n') || null;
	  }
	}

	function resolveTagDirective({
	  tagPrefixes
	}, directive) {
	  const [handle, prefix] = directive.parameters;

	  if (!handle || !prefix) {
	    const msg = 'Insufficient parameters given for %TAG directive';
	    throw new PlainValueEc8e588e.YAMLSemanticError(directive, msg);
	  }

	  if (tagPrefixes.some(p => p.handle === handle)) {
	    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';
	    throw new PlainValueEc8e588e.YAMLSemanticError(directive, msg);
	  }

	  return {
	    handle,
	    prefix
	  };
	}

	function resolveYamlDirective(doc, directive) {
	  let [version] = directive.parameters;
	  if (directive.name === 'YAML:1.0') version = '1.0';

	  if (!version) {
	    const msg = 'Insufficient parameters given for %YAML directive';
	    throw new PlainValueEc8e588e.YAMLSemanticError(directive, msg);
	  }

	  if (!documentOptions[version]) {
	    const v0 = doc.version || doc.options.version;
	    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
	    doc.warnings.push(new PlainValueEc8e588e.YAMLWarning(directive, msg));
	  }

	  return version;
	}

	function parseDirectives(doc, directives, prevDoc) {
	  const directiveComments = [];
	  let hasDirectives = false;

	  for (const directive of directives) {
	    const {
	      comment,
	      name
	    } = directive;

	    switch (name) {
	      case 'TAG':
	        try {
	          doc.tagPrefixes.push(resolveTagDirective(doc, directive));
	        } catch (error) {
	          doc.errors.push(error);
	        }

	        hasDirectives = true;
	        break;

	      case 'YAML':
	      case 'YAML:1.0':
	        if (doc.version) {
	          const msg = 'The %YAML directive must only be given at most once per document.';
	          doc.errors.push(new PlainValueEc8e588e.YAMLSemanticError(directive, msg));
	        }

	        try {
	          doc.version = resolveYamlDirective(doc, directive);
	        } catch (error) {
	          doc.errors.push(error);
	        }

	        hasDirectives = true;
	        break;

	      default:
	        if (name) {
	          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
	          doc.warnings.push(new PlainValueEc8e588e.YAMLWarning(directive, msg));
	        }

	    }

	    if (comment) directiveComments.push(comment);
	  }

	  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {
	    const copyTagPrefix = ({
	      handle,
	      prefix
	    }) => ({
	      handle,
	      prefix
	    });

	    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
	    doc.version = prevDoc.version;
	  }

	  doc.commentBefore = directiveComments.join('\n') || null;
	}

	function assertCollection(contents) {
	  if (contents instanceof resolveSeq4a68b39b.Collection) return true;
	  throw new Error('Expected a YAML collection as document contents');
	}

	class Document$1 {
	  constructor(options) {
	    this.anchors = new Anchors(options.anchorPrefix);
	    this.commentBefore = null;
	    this.comment = null;
	    this.contents = null;
	    this.directivesEndMarker = null;
	    this.errors = [];
	    this.options = options;
	    this.schema = null;
	    this.tagPrefixes = [];
	    this.version = null;
	    this.warnings = [];
	  }

	  add(value) {
	    assertCollection(this.contents);
	    return this.contents.add(value);
	  }

	  addIn(path, value) {
	    assertCollection(this.contents);
	    this.contents.addIn(path, value);
	  }

	  delete(key) {
	    assertCollection(this.contents);
	    return this.contents.delete(key);
	  }

	  deleteIn(path) {
	    if (resolveSeq4a68b39b.isEmptyPath(path)) {
	      if (this.contents == null) return false;
	      this.contents = null;
	      return true;
	    }

	    assertCollection(this.contents);
	    return this.contents.deleteIn(path);
	  }

	  getDefaults() {
	    return Document$1.defaults[this.version] || Document$1.defaults[this.options.version] || {};
	  }

	  get(key, keepScalar) {
	    return this.contents instanceof resolveSeq4a68b39b.Collection ? this.contents.get(key, keepScalar) : undefined;
	  }

	  getIn(path, keepScalar) {
	    if (resolveSeq4a68b39b.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq4a68b39b.Scalar ? this.contents.value : this.contents;
	    return this.contents instanceof resolveSeq4a68b39b.Collection ? this.contents.getIn(path, keepScalar) : undefined;
	  }

	  has(key) {
	    return this.contents instanceof resolveSeq4a68b39b.Collection ? this.contents.has(key) : false;
	  }

	  hasIn(path) {
	    if (resolveSeq4a68b39b.isEmptyPath(path)) return this.contents !== undefined;
	    return this.contents instanceof resolveSeq4a68b39b.Collection ? this.contents.hasIn(path) : false;
	  }

	  set(key, value) {
	    assertCollection(this.contents);
	    this.contents.set(key, value);
	  }

	  setIn(path, value) {
	    if (resolveSeq4a68b39b.isEmptyPath(path)) this.contents = value;else {
	      assertCollection(this.contents);
	      this.contents.setIn(path, value);
	    }
	  }

	  setSchema(id, customTags) {
	    if (!id && !customTags && this.schema) return;
	    if (typeof id === 'number') id = id.toFixed(1);

	    if (id === '1.0' || id === '1.1' || id === '1.2') {
	      if (this.version) this.version = id;else this.options.version = id;
	      delete this.options.schema;
	    } else if (id && typeof id === 'string') {
	      this.options.schema = id;
	    }

	    if (Array.isArray(customTags)) this.options.customTags = customTags;
	    const opt = Object.assign({}, this.getDefaults(), this.options);
	    this.schema = new Schema42e9705c.Schema(opt);
	  }

	  parse(node, prevDoc) {
	    if (this.options.keepCstNodes) this.cstNode = node;
	    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
	    const {
	      directives = [],
	      contents = [],
	      directivesEndMarker,
	      error,
	      valueRange
	    } = node;

	    if (error) {
	      if (!error.source) error.source = this;
	      this.errors.push(error);
	    }

	    parseDirectives(this, directives, prevDoc);
	    if (directivesEndMarker) this.directivesEndMarker = true;
	    this.range = valueRange ? [valueRange.start, valueRange.end] : null;
	    this.setSchema();
	    this.anchors._cstAliases = [];
	    parseContents(this, contents);
	    this.anchors.resolveNodes();

	    if (this.options.prettyErrors) {
	      for (const error of this.errors) if (error instanceof PlainValueEc8e588e.YAMLError) error.makePretty();

	      for (const warn of this.warnings) if (warn instanceof PlainValueEc8e588e.YAMLError) warn.makePretty();
	    }

	    return this;
	  }

	  listNonDefaultTags() {
	    return listTagNames(this.contents).filter(t => t.indexOf(Schema42e9705c.Schema.defaultPrefix) !== 0);
	  }

	  setTagPrefix(handle, prefix) {
	    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

	    if (prefix) {
	      const prev = this.tagPrefixes.find(p => p.handle === handle);
	      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({
	        handle,
	        prefix
	      });
	    } else {
	      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);
	    }
	  }

	  toJSON(arg, onAnchor) {
	    const {
	      keepBlobsInJSON,
	      mapAsMap,
	      maxAliasCount
	    } = this.options;
	    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq4a68b39b.Scalar));
	    const ctx = {
	      doc: this,
	      indentStep: '  ',
	      keep,
	      mapAsMap: keep && !!mapAsMap,
	      maxAliasCount,
	      stringify // Requiring directly in Pair would create circular dependencies

	    };
	    const anchorNames = Object.keys(this.anchors.map);
	    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {
	      alias: [],
	      aliasCount: 0,
	      count: 1
	    }]));
	    const res = resolveSeq4a68b39b.toJSON(this.contents, arg, ctx);
	    if (typeof onAnchor === 'function' && ctx.anchors) for (const {
	      count,
	      res
	    } of ctx.anchors.values()) onAnchor(res, count);
	    return res;
	  }

	  toString() {
	    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
	    const indentSize = this.options.indent;

	    if (!Number.isInteger(indentSize) || indentSize <= 0) {
	      const s = JSON.stringify(indentSize);
	      throw new Error(`"indent" option must be a positive integer, not ${s}`);
	    }

	    this.setSchema();
	    const lines = [];
	    let hasDirectives = false;

	    if (this.version) {
	      let vd = '%YAML 1.2';

	      if (this.schema.name === 'yaml-1.1') {
	        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
	      }

	      lines.push(vd);
	      hasDirectives = true;
	    }

	    const tagNames = this.listNonDefaultTags();
	    this.tagPrefixes.forEach(({
	      handle,
	      prefix
	    }) => {
	      if (tagNames.some(t => t.indexOf(prefix) === 0)) {
	        lines.push(`%TAG ${handle} ${prefix}`);
	        hasDirectives = true;
	      }
	    });
	    if (hasDirectives || this.directivesEndMarker) lines.push('---');

	    if (this.commentBefore) {
	      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
	      lines.unshift(this.commentBefore.replace(/^/gm, '#'));
	    }

	    const ctx = {
	      anchors: {},
	      doc: this,
	      indent: '',
	      indentStep: ' '.repeat(indentSize),
	      stringify // Requiring directly in nodes would create circular dependencies

	    };
	    let chompKeep = false;
	    let contentComment = null;

	    if (this.contents) {
	      if (this.contents instanceof resolveSeq4a68b39b.Node) {
	        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
	        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

	        ctx.forceBlockIndent = !!this.comment;
	        contentComment = this.contents.comment;
	      }

	      const onChompKeep = contentComment ? null : () => chompKeep = true;
	      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
	      lines.push(resolveSeq4a68b39b.addComment(body, '', contentComment));
	    } else if (this.contents !== undefined) {
	      lines.push(stringify(this.contents, ctx));
	    }

	    if (this.comment) {
	      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
	      lines.push(this.comment.replace(/^/gm, '#'));
	    }

	    return lines.join('\n') + '\n';
	  }

	}

	PlainValueEc8e588e._defineProperty(Document$1, "defaults", documentOptions);

	var Document_1 = Document$1;
	var defaultOptions_1 = defaultOptions;
	var scalarOptions_1 = scalarOptions;

	var Document2cf6b08c = {
		Document: Document_1,
		defaultOptions: defaultOptions_1,
		scalarOptions: scalarOptions_1
	};

	function createNode$1(value, wrapScalars = true, tag) {
	  if (tag === undefined && typeof wrapScalars === 'string') {
	    tag = wrapScalars;
	    wrapScalars = true;
	  }

	  const options = Object.assign({}, Document2cf6b08c.Document.defaults[Document2cf6b08c.defaultOptions.version], Document2cf6b08c.defaultOptions);
	  const schema = new Schema42e9705c.Schema(options);
	  return schema.createNode(value, wrapScalars, tag);
	}

	class Document$2 extends Document2cf6b08c.Document {
	  constructor(options) {
	    super(Object.assign({}, Document2cf6b08c.defaultOptions, options));
	  }

	}

	function parseAllDocuments(src, options) {
	  const stream = [];
	  let prev;

	  for (const cstDoc of parseCst.parse(src)) {
	    const doc = new Document$2(options);
	    doc.parse(cstDoc, prev);
	    stream.push(doc);
	    prev = doc;
	  }

	  return stream;
	}

	function parseDocument(src, options) {
	  const cst = parseCst.parse(src);
	  const doc = new Document$2(options).parse(cst[0]);

	  if (cst.length > 1) {
	    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
	    doc.errors.unshift(new PlainValueEc8e588e.YAMLSemanticError(cst[1], errMsg));
	  }

	  return doc;
	}

	function parse$1(src, options) {
	  const doc = parseDocument(src, options);
	  doc.warnings.forEach(warning => warnings39684f17.warn(warning));
	  if (doc.errors.length > 0) throw doc.errors[0];
	  return doc.toJSON();
	}

	function stringify$1(value, options) {
	  const doc = new Document$2(options);
	  doc.contents = value;
	  return String(doc);
	}

	const YAML = {
	  createNode: createNode$1,
	  defaultOptions: Document2cf6b08c.defaultOptions,
	  Document: Document$2,
	  parse: parse$1,
	  parseAllDocuments,
	  parseCST: parseCst.parse,
	  parseDocument,
	  scalarOptions: Document2cf6b08c.scalarOptions,
	  stringify: stringify$1
	};

	var YAML_1 = YAML;

	var dist = {
		YAML: YAML_1
	};

	var yaml = dist.YAML;

	var directives = (str => {
	  const res = [];
	  let reg = /(?=<!--)([\s\S]*?)-->/mig;
	  const matches = str.match(reg);

	  if (matches) {
	    matches.forEach(c => {
	      reg = /<!--([\s\S]*?)-->/mig;
	      const rg = reg.exec(c);
	      const prp = rg[1] ? rg[1].trim() : null;

	      if (prp) {
	        try {
	          res.push(yaml.parse(prp));
	        } catch (e) {// console.log(e)
	        }
	      }
	    });
	  }

	  return res;
	});

	var blockFromSrc = (html => {
	  let block = null;
	  const el = document.createElement('div');
	  el.innerHTML = html;
	  const hasH1 = el.querySelector('h1');
	  const hasH2 = el.querySelector('h2');
	  const hasH3 = el.querySelector('h3');
	  const hasHeading = el.querySelector('h1,h2,h3');
	  let hasText = el.querySelector('h4,h5,h6,p,ul,ol,blockquote,code,table');
	  const hasImage = el.querySelector('img');
	  const hasTable = el.querySelector('table'); // image vars

	  let url;
	  let alt;
	  let onlyImage;

	  if (hasImage) {
	    url = hasImage.getAttribute('src');
	    alt = hasImage.getAttribute('alt');
	    onlyImage = !hasHeading && hasText.innerHTML === hasImage.outerHTML;
	    hasText = hasText.innerHTML !== hasImage.outerHTML;
	  }

	  const onlyTable = hasTable && !hasHeading && hasText.innerHTML === hasTable.innerHTML; // style vars

	  let textVar = 'text';
	  let colorVar = 'main';

	  if (!hasText && hasH1) {
	    textVar = 'title';
	    colorVar = 'sec';
	  }

	  if (!hasText && hasH2 && !hasH1) {
	    textVar = 'section';
	    colorVar = 'alt';
	  }

	  if (!hasText && hasH3 && !hasH2 && !hasH1) {
	    textVar = 'mention';
	    colorVar = 'main';
	  } // HEADING


	  if (hasHeading && !hasText) {
	    block = {
	      type: 'text',
	      text: html,
	      scale: 3,
	      textVar,
	      colorVar
	    };
	  } // TEXT


	  if (hasText) {
	    block = {
	      type: 'text',
	      text: html,
	      textVar: 'text',
	      scale: 2
	    };
	  } // IMAGE


	  if (onlyImage) {
	    const imageSize = alt || 'contain';
	    const imagePadding = imageSize !== 'cover' ? '3rem' : '';
	    block = {
	      type: 'image',
	      url,
	      imageSize,
	      imagePadding,
	      colorBack: 'white'
	    };
	  } // BACK


	  if (hasImage && alt === 'back') {
	    hasImage.parentNode.parentNode.removeChild(hasImage.parentNode);
	    block = {
	      type: 'group',
	      layout: 'stack',
	      blocks: [{
	        type: 'image',
	        url
	      }, {
	        type: 'text',
	        text: el.innerHTML,
	        scale: 3
	      }],
	      textVar,
	      colorVar
	    };
	  }

	  if (onlyTable) {
	    block = {
	      type: 'text',
	      text: html,
	      textVar: 'text',
	      textWidth: '100%',
	      scale: 2
	    };
	  }

	  return block;
	});

	const parser = new DOMParser();
	var blocks = ['image', 'text', 'embed', 'youtube', 'svg', 'video', 'vegalite', 'chartjs', 'fitty'];
	var blockFromDef = (src => {
	  const dom = parser.parseFromString(src, 'text/html').body;
	  const pre = dom.querySelectorAll('pre');
	  const precode = dom.querySelectorAll('pre > code');
	  const preArr = Array.from(pre);
	  const blocksRes = [];
	  var nsrc = src;

	  if (precode.length > 0) {
	    preArr.forEach(el => {
	      const code = el.querySelector('code');
	      const type = code.getAttribute('class').replace('language-', '');
	      const isBlock = blocks.indexOf(type) >= 0;

	      if (isBlock) {
	        const b = yaml.parse(code.innerHTML);
	        b.type = type;
	        blocksRes.push(b);
	        nsrc = nsrc.replace(el.innerHTML, '');
	      }
	    });
	    return {
	      blocks: blocksRes,
	      src: nsrc
	    };
	  }

	  return {
	    blocks: [],
	    src: nsrc
	  };
	});

	const def = {
	  sceneSeparator: '---',
	  fragmentSeparator: '–'
	};

	marked_1.setOptions({
	  gfm: true,
	  breaks: true
	});
	var main = (str => {
	  const project = {
	    scenes: []
	  };
	  const scenes = str.split('\n' + def.sceneSeparator + '\n');
	  const arr = [];
	  scenes.forEach(d => {
	    // create the scene
	    const scene = {
	      blocks: []
	    }; // clean up the scene raw text

	    const text = d.trim(); // transform into HTML

	    const srcHtml = marked_1(text); // parse the HTML to intercept block definitions

	    const blkdef = blockFromDef(srcHtml); // parse the src text to create blocks

	    const parts = blkdef.src.split('\n<p>' + def.fragmentSeparator + '</p>\n');
	    parts.forEach(s => {
	      const blk = blockFromSrc(s);
	      if (blk) scene.blocks.push(blk);
	    }); // add additional blocks from definition, if any

	    scene.blocks = scene.blocks.concat(blkdef.blocks); // check if there's only one block

	    const oneBlock = scene.blocks.length === 1 ? scene.blocks[0] : null; // set the colorVar to scene the same as the first block

	    if (oneBlock) {
	      if (oneBlock.colorVar) scene.colorVar = oneBlock.colorVar || null;
	    } // parse directives and set into the scene


	    const dir = directives(text);
	    dir.forEach(d => {
	      for (const k in d) {
	        scene[k] = d[k]; // only if there's one block, we propagate the properties also to the block level

	        if (oneBlock) {
	          oneBlock[k] = scene[k];
	        }
	      }
	    }); // add scene to array

	    arr.push(scene);
	  });
	  project.scenes = arr;
	  return project;
	});

	const findIndex = (code, line) => {
	  let sceneNum = 0;
	  const lines = code.split('\n');

	  for (var j = 0; j <= line; j++) {
	    const l = lines[j];

	    if (line === j) {
	      return sceneNum;
	    }

	    if (l && l.indexOf(def.sceneSeparator) === 0) sceneNum++;
	  }

	  return sceneNum;
	};

	const findRange = (code, index) => {
	  let sceneNum = -1;
	  let start = 0;
	  let end = 0;
	  const lines = code.split('\n');

	  for (var j = 0; j <= lines.length; j++) {
	    const l = lines[j];

	    if (l && l.indexOf(def.sceneSeparator) === 0) {
	      sceneNum++;
	    }

	    if (index === sceneNum) {
	      end = j;
	      return {
	        start,
	        end
	      };
	    }

	    if (l && l.indexOf(def.sceneSeparator) === 0) {
	      start = j + 1;
	    }
	  }

	  return {
	    start,
	    end
	  };
	};

	var utils = {
	  findIndex,
	  findRange
	};

	var index = {
	  parse: main,
	  findIndex: utils.findIndex,
	  findRange: utils.findRange,
	  setting: def
	};

	return index;

})));
